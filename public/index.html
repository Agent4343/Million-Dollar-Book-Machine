<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Million Dollar Book Machine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            min-height: 100vh;
            color: #e4e4e4;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 1rem; }

        /* Login */
        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .login-card {
            background: rgba(255,255,255,0.05);
            padding: 2rem;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }
        .login-card h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 1rem;
        }
        .header h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.5rem;
        }

        /* Forms */
        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        label { display: block; margin-bottom: 0.25rem; color: #888; font-size: 0.9rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }
        .btn-danger { background: rgba(231,76,60,0.2); color: #e74c3c; }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card h2 { color: #00d4ff; margin-bottom: 1rem; font-size: 1.2rem; }
        .card h3 { color: #888; margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; }

        /* Grid */
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
        @media (max-width: 768px) {
            .grid-2, .grid-3 { grid-template-columns: 1fr; }
        }

        /* Pipeline View */
        .pipeline { display: flex; flex-direction: column; gap: 0.5rem; }
        .layer {
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid #333;
        }
        .layer.available { border-left-color: #00d4ff; }
        .layer.in-progress { border-left-color: #f39c12; }
        .layer.completed { border-left-color: #2ecc71; }
        .layer.locked { opacity: 0.5; }
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .layer-name { font-weight: 600; }
        .layer-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        .agents { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem; }
        .agent {
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.2s;
        }
        .agent:hover { background: rgba(0,212,255,0.2); }
        .agent.passed { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .agent.failed { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .agent.running { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Output Panel */
        .output-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }
        .output-panel pre {
            font-family: monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            color: #00d4ff;
        }

        /* Tabs */
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        .tab {
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
        }
        .tab.active { background: linear-gradient(90deg, #00d4ff, #7b2cbf); }

        /* Hidden */
        .hidden { display: none !important; }

        /* API Status Indicator */
        .api-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .api-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            animation: pulse 2s infinite;
        }
        .api-status.active .api-status-dot {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46,204,113,0.5);
        }
        .api-status.inactive .api-status-dot {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231,76,60,0.5);
            animation: none;
        }
        .api-status.active {
            border-color: rgba(46,204,113,0.3);
            background: rgba(46,204,113,0.1);
        }
        .api-status.inactive {
            border-color: rgba(231,76,60,0.3);
            background: rgba(231,76,60,0.1);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stat { text-align: center; padding: 1rem; }
        .stat-value { font-size: 2rem; font-weight: 700; color: #00d4ff; }
        .stat-label { font-size: 0.8rem; color: #888; }

        /* Progress Bar */
        .progress-container {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .progress-title { font-weight: 600; font-size: 1.1rem; }
        .progress-percent { color: #00d4ff; font-weight: 700; font-size: 1.2rem; }
        .progress-bar {
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        .progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #888;
        }

        /* Run Full Button */
        .btn-full-pipeline {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            color: #fff;
            width: 100%;
            padding: 1rem;
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .btn-full-pipeline:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(46,204,113,0.3); }
        .btn-full-pipeline:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Running State */
        .running-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Save/Load Buttons */
        .btn-save { background: linear-gradient(90deg, #3498db, #2980b9); color: #fff; }
        .btn-load { background: rgba(52,152,219,0.2); color: #3498db; border: 1px solid #3498db; }
        .btn-export { background: linear-gradient(90deg, #9b59b6, #8e44ad); color: #fff; }
        .btn-write { background: linear-gradient(90deg, #e67e22, #d35400); color: #fff; }
        .file-input-hidden { display: none; }
        .save-load-section {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .auto-save-indicator {
            font-size: 0.75rem;
            color: #2ecc71;
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .auto-save-indicator::before {
            content: "●";
            font-size: 0.5rem;
        }

        /* Chapter Writer Section */
        .chapter-writer-section {
            background: rgba(230,126,34,0.1);
            border: 1px solid rgba(230,126,34,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .chapter-writer-section h3 {
            color: #e67e22;
            margin-bottom: 0.75rem;
        }
        .chapter-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .chapter-item {
            padding: 0.5rem 0.75rem;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .chapter-item:hover { background: rgba(230,126,34,0.2); }
        .chapter-item.written { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .chapter-item.writing { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Export Section */
        .export-section {
            background: rgba(155,89,182,0.1);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .export-section h3 {
            color: #9b59b6;
            margin-bottom: 0.75rem;
        }
        .export-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Screen -->
        <div class="login-screen" id="loginScreen">
            <div class="login-card">
                <h1>Million Dollar Book Machine</h1>
                <p style="color:#888;margin-bottom:2rem;">AI-Powered Book Development</p>
                <form id="loginForm">
                    <input type="password" id="password" placeholder="Enter password" required>
                    <button type="submit" class="btn btn-primary" style="width:100%">Sign In</button>
                </form>
                <p id="loginError" class="hidden" style="color:#e74c3c;margin-top:1rem;">Invalid password</p>
            </div>
        </div>

        <!-- Main App -->
        <div id="appContent" class="hidden">
            <div class="header">
                <h1>Million Dollar Book Machine</h1>
                <div style="display:flex;align-items:center;gap:1rem;">
                    <div id="apiStatus" class="api-status">
                        <span class="api-status-dot"></span>
                        <span class="api-status-text">Checking API...</span>
                    </div>
                    <button class="btn btn-danger btn-small" onclick="logout()">Sign Out</button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <div class="tab active" onclick="showTab('projects')">Projects</div>
                <div class="tab" onclick="showTab('newProject')">New Project</div>
                <div class="tab" onclick="showTab('pipeline')">Pipeline</div>
                <div class="tab" onclick="showTab('storyBible')">Story Bible</div>
            </div>

            <!-- Projects Tab -->
            <div id="projectsTab">
                <div class="card">
                    <h2>Your Projects</h2>
                    <div id="projectsList"></div>
                    <div class="save-load-section">
                        <button class="btn btn-load btn-small" onclick="document.getElementById('importFile').click()">
                            Import Project
                        </button>
                        <input type="file" id="importFile" class="file-input-hidden" accept=".json" onchange="importProject(event)">
                        <button class="btn btn-secondary btn-small" onclick="restoreFromLocalStorage()">
                            Restore from Browser
                        </button>
                        <span class="auto-save-indicator" id="autoSaveStatus">Auto-save enabled</span>
                    </div>
                </div>
            </div>

            <!-- New Project Tab -->
            <div id="newProjectTab" class="hidden">
                <div class="card">
                    <h2>Create New Book Project</h2>
                    <form id="newProjectForm">
                        <div class="grid-2">
                            <div>
                                <label>Book Title *</label>
                                <input type="text" id="projectTitle" required placeholder="Your book title">
                            </div>
                            <div>
                                <label>Genre *</label>
                                <select id="projectGenre" required>
                                    <option value="">Select genre</option>
                                    <option value="literary_fiction">Literary Fiction</option>
                                    <option value="thriller">Thriller</option>
                                    <option value="mystery">Mystery</option>
                                    <option value="romance">Romance</option>
                                    <option value="sci_fi">Science Fiction</option>
                                    <option value="fantasy">Fantasy</option>
                                    <option value="horror">Horror</option>
                                    <option value="memoir">Memoir</option>
                                    <option value="self_help">Self-Help</option>
                                    <option value="business">Business</option>
                                </select>
                            </div>
                        </div>
                        <label>Book Description / Vision</label>
                        <textarea id="projectDescription" rows="4" placeholder="Describe your book idea..."></textarea>
                        <div class="grid-2">
                            <div>
                                <label>Target Word Count</label>
                                <input type="number" id="projectWordCount" value="80000">
                            </div>
                            <div>
                                <label>Target Audience</label>
                                <input type="text" id="projectAudience" placeholder="e.g., Adults 25-45">
                            </div>
                        </div>
                        <label>Comparable Titles (comma separated)</label>
                        <input type="text" id="projectComps" placeholder="e.g., The Alchemist, Atomic Habits">
                        <label>Themes (comma separated)</label>
                        <input type="text" id="projectThemes" placeholder="e.g., redemption, identity, love">
                        <button type="submit" class="btn btn-primary">Create Project</button>
                    </form>
                </div>
            </div>

            <!-- Pipeline Tab -->
            <div id="pipelineTab" class="hidden">
                <div id="noProjectSelected" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to view its pipeline</p>
                </div>
                <div id="pipelineView" class="hidden">
                    <!-- Progress Bar -->
                    <div class="progress-container">
                        <div class="progress-header">
                            <span class="progress-title" id="progressTitle">Book Development Progress</span>
                            <span class="progress-percent" id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-details">
                            <span id="progressStatus">Ready to start</span>
                            <span id="progressAgents">0 / 0 agents completed</span>
                        </div>
                        <button class="btn btn-full-pipeline" id="runFullPipelineBtn" onclick="runFullPipeline()">
                            Run Full Pipeline
                        </button>
                    </div>

                    <div class="grid-3" style="margin-bottom:1rem;">
                        <div class="card stat">
                            <div class="stat-value" id="statLayers">0</div>
                            <div class="stat-label">Layers</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statAgents">0</div>
                            <div class="stat-label">Agents</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statCompleted">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                    </div>

                    <div class="grid-2">
                        <div class="card">
                            <h2 id="pipelineProjectTitle">Pipeline</h2>
                            <div class="pipeline" id="pipelineLayers"></div>
                            <div style="margin-top:1rem;">
                                <button class="btn btn-primary btn-small" id="runNextBtn" onclick="runNextAgent()">Run Next Agent</button>
                                <button class="btn btn-secondary btn-small" id="runAvailableBtn" onclick="runAllAvailable()">Run All Available</button>
                                <button class="btn btn-save btn-small" onclick="exportProject()">Save Project</button>
                            </div>

                            <!-- Export Section -->
                            <div class="export-section">
                                <h3>Export Documents</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.75rem;">Download your book in different formats</p>
                                <div class="export-buttons">
                                    <button class="btn btn-export btn-small" onclick="exportDocx()">Word Document (.docx)</button>
                                    <button class="btn btn-export btn-small" onclick="exportEpub()">Kindle/EPUB (.epub)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportOutline()">Outline (MD)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportManuscript()">Manuscript (MD)</button>
                                </div>
                                <p id="exportStatus" style="font-size:0.8rem;color:#888;margin-top:0.5rem;"></p>
                            </div>

                            <!-- Chapter Writer Section -->
                            <div class="chapter-writer-section" id="chapterWriterSection">
                                <h3>Chapter Writer</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.5rem;">Write individual chapters after completing Layer 10 (Chapter Blueprint)</p>
                                <div id="chapterWriterStatus"></div>
                                <div class="chapter-list" id="chapterList"></div>
                                <div style="margin-top:0.75rem;">
                                    <button class="btn btn-write btn-small" id="writeAllChaptersBtn" onclick="writeAllChapters()">Write All Chapters</button>
                                    <span id="chapterWriteProgress" style="margin-left:0.5rem;font-size:0.85rem;color:#888;"></span>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <h2>Agent Output</h2>
                            <p id="selectedAgentName" style="color:#888;margin-bottom:0.5rem;">Select an agent to view output</p>
                            <div class="output-panel">
                                <pre id="agentOutput">No output yet</pre>
                            </div>

                            <!-- Chapter Preview -->
                            <div id="chapterPreview" class="hidden" style="margin-top:1rem;">
                                <h3 style="color:#e67e22;margin-bottom:0.5rem;">Chapter Preview</h3>
                                <div class="output-panel" style="max-height:300px;">
                                    <pre id="chapterText" style="white-space:pre-wrap;color:#fff;"></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Story Bible Tab -->
            <div id="storyBibleTab" class="hidden">
                <div id="noProjectForBible" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to view/edit its Story Bible</p>
                </div>
                <div id="storyBibleView" class="hidden">
                    <div class="card">
                        <h2>Story Bible - <span id="bibleProjTitle"></span></h2>
                        <p style="color:#888;margin-bottom:1rem;">The Story Bible contains all canonical facts about your story. Edit these to ensure consistency across chapters.</p>

                        <div class="grid-2">
                            <div>
                                <h3>Characters</h3>
                                <textarea id="bibleCharacters" rows="8" placeholder="List your characters with their key traits, backgrounds, and roles..."></textarea>
                            </div>
                            <div>
                                <h3>Locations</h3>
                                <textarea id="bibleLocations" rows="8" placeholder="List your locations with descriptions and important details..."></textarea>
                            </div>
                        </div>

                        <div class="grid-2">
                            <div>
                                <h3>Timeline</h3>
                                <textarea id="bibleTimeline" rows="6" placeholder="Key dates and events in chronological order..."></textarea>
                            </div>
                            <div>
                                <h3>World Rules</h3>
                                <textarea id="bibleRules" rows="6" placeholder="Rules of your story world (magic systems, social rules, etc.)..."></textarea>
                            </div>
                        </div>

                        <h3>Relationships</h3>
                        <textarea id="bibleRelationships" rows="4" placeholder="Key relationships between characters..."></textarea>

                        <h3>Important Facts / Consistency Notes</h3>
                        <textarea id="bibleFacts" rows="4" placeholder="Other important facts that must remain consistent..."></textarea>

                        <div style="margin-top:1rem;display:flex;gap:1rem;">
                            <button class="btn btn-primary" onclick="saveStoryBible()">Save Story Bible</button>
                            <button class="btn btn-secondary" onclick="loadStoryBible()">Reload from Server</button>
                            <span id="bibleSaveStatus" style="color:#888;align-self:center;"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentProject = null;
        let projectData = null;

        // =================================================================
        // Auto-restore helper for stateless serverless
        // =================================================================

        async function ensureProjectOnServer(projectId) {
            // Check if project exists on server
            const res = await fetch(`/api/projects/${projectId}`, {credentials: 'include'});

            if (res.ok) {
                return true; // Project exists
            }

            if (res.status === 404) {
                // Try to restore from localStorage
                const saved = getLocalStorageProjects();
                const project = saved[projectId];

                if (project) {
                    console.log('Auto-restoring project from localStorage...');
                    try {
                        const importRes = await fetch('/api/projects/import', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            credentials: 'include',
                            body: JSON.stringify(project)
                        });

                        if (importRes.ok) {
                            console.log('Project restored successfully');
                            return true;
                        }
                    } catch (error) {
                        console.error('Failed to restore project:', error);
                    }
                }
            }

            return false;
        }

        // Auth
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const res = await fetch('/api/auth/login', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify({password: document.getElementById('password').value})
            });
            if (res.ok) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            } else {
                document.getElementById('loginError').classList.remove('hidden');
            }
        });

        async function logout() {
            await fetch('/api/auth/logout', {method: 'POST', credentials: 'include'});
            location.reload();
        }

        async function checkAuth() {
            const res = await fetch('/api/auth/check', {credentials: 'include'});
            const data = await res.json();
            if (data.authenticated) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            }
        }

        // API Status Check
        async function checkApiStatus() {
            const statusEl = document.getElementById('apiStatus');
            const dotEl = statusEl.querySelector('.api-status-dot');
            const textEl = statusEl.querySelector('.api-status-text');

            try {
                const res = await fetch('/api/system/llm-status', {credentials: 'include'});
                const data = await res.json();

                if (data.enabled) {
                    statusEl.className = 'api-status active';
                    textEl.textContent = `API Active (${data.model || 'Claude'})`;
                } else {
                    statusEl.className = 'api-status inactive';
                    textEl.textContent = 'API Inactive - Demo Mode';
                    console.warn('API Status:', data.message);
                }
            } catch (error) {
                statusEl.className = 'api-status inactive';
                textEl.textContent = 'API Error';
                console.error('API Status Error:', error);
            }
        }

        // Refresh API status periodically
        setInterval(checkApiStatus, 60000); // Check every minute

        // Tabs
        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="showTab('${tab}')"]`).classList.add('active');
            document.getElementById('projectsTab').classList.add('hidden');
            document.getElementById('newProjectTab').classList.add('hidden');
            document.getElementById('pipelineTab').classList.add('hidden');
            document.getElementById('storyBibleTab').classList.add('hidden');
            document.getElementById(tab + 'Tab').classList.remove('hidden');

            // Load Story Bible when tab is shown
            if (tab === 'storyBible' && currentProject) {
                loadStoryBible();
            }
        }

        // Story Bible Functions
        async function loadStoryBible() {
            if (!currentProject) {
                document.getElementById('noProjectForBible').classList.remove('hidden');
                document.getElementById('storyBibleView').classList.add('hidden');
                return;
            }

            document.getElementById('noProjectForBible').classList.add('hidden');
            document.getElementById('storyBibleView').classList.remove('hidden');
            document.getElementById('bibleProjTitle').textContent = projectData?.title || 'Unknown';
            document.getElementById('bibleSaveStatus').textContent = 'Loading...';

            try {
                const res = await fetch(`/api/projects/${currentProject}/story-bible`, {credentials: 'include'});
                const data = await res.json();

                if (data.status === 'available' && data.story_bible) {
                    const bible = data.story_bible;
                    // Populate text areas from story bible data
                    document.getElementById('bibleCharacters').value = formatBibleSection(bible.character_registry);
                    document.getElementById('bibleLocations').value = formatBibleSection(bible.location_registry);
                    document.getElementById('bibleTimeline').value = formatBibleSection(bible.timeline);
                    document.getElementById('bibleRules').value = formatBibleSection(bible.consistency_rules);
                    document.getElementById('bibleRelationships').value = formatBibleSection(bible.relationship_map);
                    document.getElementById('bibleFacts').value = formatBibleSection(bible.backstory_facts || bible.terminology);
                    document.getElementById('bibleSaveStatus').textContent = 'Loaded';
                } else {
                    document.getElementById('bibleSaveStatus').textContent = data.message || 'No Story Bible yet - run the story_bible agent first or enter manually';
                }
            } catch (error) {
                console.error('Error loading story bible:', error);
                document.getElementById('bibleSaveStatus').textContent = 'Error loading';
            }
        }

        function formatBibleSection(data) {
            if (!data) return '';
            if (typeof data === 'string') return data;
            if (Array.isArray(data)) {
                return data.map(item => {
                    if (typeof item === 'string') return item;
                    return JSON.stringify(item, null, 2);
                }).join('\n\n');
            }
            return JSON.stringify(data, null, 2);
        }

        async function saveStoryBible() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            document.getElementById('bibleSaveStatus').textContent = 'Saving...';

            const storyBible = {
                character_registry: document.getElementById('bibleCharacters').value,
                location_registry: document.getElementById('bibleLocations').value,
                timeline: document.getElementById('bibleTimeline').value,
                consistency_rules: document.getElementById('bibleRules').value,
                relationship_map: document.getElementById('bibleRelationships').value,
                backstory_facts: document.getElementById('bibleFacts').value,
                terminology: {}
            };

            try {
                const res = await fetch(`/api/projects/${currentProject}/story-bible`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify({story_bible: storyBible})
                });

                if (res.ok) {
                    document.getElementById('bibleSaveStatus').textContent = 'Saved successfully!';
                    setTimeout(() => {
                        document.getElementById('bibleSaveStatus').textContent = '';
                    }, 3000);
                } else {
                    const error = await res.json();
                    document.getElementById('bibleSaveStatus').textContent = 'Error: ' + (error.detail || 'Failed to save');
                }
            } catch (error) {
                console.error('Error saving story bible:', error);
                document.getElementById('bibleSaveStatus').textContent = 'Error saving';
            }
        }

        // Projects
        async function loadProjects() {
            const res = await fetch('/api/projects', {credentials: 'include'});
            const data = await res.json();
            const container = document.getElementById('projectsList');

            if (data.projects.length === 0) {
                container.innerHTML = '<p style="color:#888;">No projects yet. Create your first book!</p>';
            } else {
                container.innerHTML = data.projects.map(p => `
                    <div class="card" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <div>
                            <strong>${p.title}</strong>
                            <span style="color:#888;margin-left:1rem;">${p.status}</span>
                        </div>
                        <button class="btn btn-primary btn-small" onclick="selectProject('${p.project_id}')">Open</button>
                    </div>
                `).join('');
            }
        }

        async function selectProject(projectId) {
            currentProject = projectId;
            await loadProjectPipeline();
            showTab('pipeline');
        }

        async function loadProjectPipeline() {
            if (!currentProject) return;

            // Ensure project exists on server (auto-restore if needed)
            const exists = await ensureProjectOnServer(currentProject);
            if (!exists) {
                alert('Project not found. Please create a new project.');
                currentProject = null;
                showTab('projects');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}`, {credentials: 'include'});
            projectData = await res.json();

            document.getElementById('noProjectSelected').classList.add('hidden');
            document.getElementById('pipelineView').classList.remove('hidden');
            document.getElementById('pipelineProjectTitle').textContent = projectData.title;

            // Stats
            const layers = Object.keys(projectData.layers).length;
            let agents = 0, completed = 0;
            Object.values(projectData.layers).forEach(l => {
                Object.values(l.agents).forEach(a => {
                    agents++;
                    if (a.status === 'passed') completed++;
                });
            });
            document.getElementById('statLayers').textContent = layers;
            document.getElementById('statAgents').textContent = agents;
            document.getElementById('statCompleted').textContent = completed;

            // Update progress bar
            const percent = agents > 0 ? Math.round((completed / agents) * 100) : 0;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressAgents').textContent = `${completed} / ${agents} agents completed`;

            // Update progress status
            let status = 'Ready to start';
            if (completed === agents && agents > 0) {
                status = 'Pipeline complete!';
                document.getElementById('runFullPipelineBtn').textContent = 'Pipeline Complete';
                document.getElementById('runFullPipelineBtn').disabled = true;
            } else if (completed > 0) {
                const currentLayer = projectData.current_layer || 0;
                status = `Layer ${currentLayer} in progress`;
            }
            document.getElementById('progressStatus').textContent = status;

            // Render pipeline
            const container = document.getElementById('pipelineLayers');
            container.innerHTML = '';

            Object.entries(projectData.layers).sort((a,b) => a[0] - b[0]).forEach(([layerId, layer]) => {
                const div = document.createElement('div');
                div.className = `layer ${layer.status}`;
                div.innerHTML = `
                    <div class="layer-header">
                        <span class="layer-name">Layer ${layerId}: ${layer.name}</span>
                        <span class="layer-status">${layer.status}</span>
                    </div>
                    <div class="agents">
                        ${Object.entries(layer.agents).map(([aid, a]) => `
                            <span class="agent ${a.status}" onclick="viewAgent('${aid}')" title="${a.status}">${a.status === 'passed' ? '✓' : a.status === 'failed' ? '✗' : '○'} ${aid}</span>
                        `).join('')}
                    </div>
                `;
                container.appendChild(div);
            });
        }

        async function viewAgent(agentId) {
            if (!currentProject) return;
            document.getElementById('selectedAgentName').textContent = agentId;

            const res = await fetch(`/api/projects/${currentProject}/agent/${agentId}/output`, {credentials: 'include'});
            const data = await res.json();

            if (data.output) {
                document.getElementById('agentOutput').textContent = JSON.stringify(data.output, null, 2);
            } else {
                document.getElementById('agentOutput').textContent = data.message || 'No output yet';
            }
        }

        async function runNextAgent() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            if (data.available_agents.length > 0) {
                const agent = data.available_agents[0];
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
                await loadProjectPipeline();
                viewAgent(agent.id);
            } else {
                alert('No agents available to run');
            }
        }

        async function runAllAvailable() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            for (const agent of data.available_agents) {
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
            }
            await loadProjectPipeline();
        }

        let isRunningPipeline = false;

        async function runFullPipeline() {
            if (!currentProject || isRunningPipeline) return;

            // Ensure project exists before starting
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            isRunningPipeline = true;
            const btn = document.getElementById('runFullPipelineBtn');
            const nextBtn = document.getElementById('runNextBtn');
            const availBtn = document.getElementById('runAvailableBtn');

            btn.disabled = true;
            nextBtn.disabled = true;
            availBtn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Running Pipeline...';

            try {
                let hasMore = true;
                let iterations = 0;
                const maxIterations = 100; // Safety limit

                while (hasMore && iterations < maxIterations) {
                    iterations++;

                    // Get available agents
                    const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
                    const data = await res.json();

                    if (data.available_agents.length === 0) {
                        hasMore = false;
                        break;
                    }

                    // Execute each available agent
                    for (const agent of data.available_agents) {
                        document.getElementById('progressStatus').textContent = `Running: ${agent.name}`;

                        const execRes = await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                            method: 'POST',
                            credentials: 'include'
                        });

                        if (!execRes.ok) {
                            console.error(`Failed to execute ${agent.id}`);
                        }

                        // Update progress after each agent
                        await loadProjectPipeline();
                        viewAgent(agent.id);
                    }
                }

                // Final update
                await loadProjectPipeline();

                if (iterations >= maxIterations) {
                    alert('Pipeline stopped: maximum iterations reached. Some agents may have failed.');
                } else {
                    // Pipeline complete - now automatically write all chapters
                    await autoWriteAllChapters();
                }
            } catch (error) {
                console.error('Pipeline error:', error);
                alert('An error occurred during pipeline execution. Check the console for details.');
            } finally {
                isRunningPipeline = false;
                btn.innerHTML = 'Run Full Pipeline';
                btn.disabled = false;
                nextBtn.disabled = false;
                availBtn.disabled = false;
                await loadProjectPipeline();
            }
        }

        // New Project
        document.getElementById('newProjectForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const body = {
                title: document.getElementById('projectTitle').value,
                genre: document.getElementById('projectGenre').value,
                description: document.getElementById('projectDescription').value,
                target_word_count: parseInt(document.getElementById('projectWordCount').value),
                target_audience: document.getElementById('projectAudience').value,
                comparable_titles: document.getElementById('projectComps').value.split(',').map(s => s.trim()).filter(s => s),
                themes: document.getElementById('projectThemes').value.split(',').map(s => s.trim()).filter(s => s)
            };

            const res = await fetch('/api/projects', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify(body)
            });

            if (res.ok) {
                const data = await res.json();
                currentProject = data.project_id;
                document.getElementById('newProjectForm').reset();
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
            }
        });

        // =================================================================
        // Save/Load Functions
        // =================================================================

        const STORAGE_KEY = 'million_dollar_book_projects';

        async function exportProject() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${data.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Also save to localStorage
                saveToLocalStorage(data);
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export project');
            }
        }

        async function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: text
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Import failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" imported successfully!`);
            } catch (error) {
                console.error('Import error:', error);
                alert('Failed to import project: ' + error.message);
            }

            // Reset file input
            event.target.value = '';
        }

        function saveToLocalStorage(projectData) {
            try {
                let saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                saved[projectData.project_id] = {
                    ...projectData,
                    saved_at: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
                updateAutoSaveStatus('Saved');
            } catch (error) {
                console.error('LocalStorage save error:', error);
            }
        }

        function getLocalStorageProjects() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        async function restoreFromLocalStorage() {
            const saved = getLocalStorageProjects();
            const projects = Object.values(saved);

            if (projects.length === 0) {
                alert('No saved projects found in browser storage');
                return;
            }

            // Show list of saved projects
            const choices = projects.map((p, i) =>
                `${i + 1}. ${p.title} (saved: ${new Date(p.saved_at).toLocaleString()})`
            ).join('\n');

            const choice = prompt(`Select a project to restore:\n\n${choices}\n\nEnter number:`);
            if (!choice) return;

            const index = parseInt(choice) - 1;
            if (index < 0 || index >= projects.length) {
                alert('Invalid selection');
                return;
            }

            const project = projects[index];

            try {
                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify(project)
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Restore failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" restored successfully!`);
            } catch (error) {
                console.error('Restore error:', error);
                alert('Failed to restore project: ' + error.message);
            }
        }

        function updateAutoSaveStatus(status) {
            const el = document.getElementById('autoSaveStatus');
            if (el) {
                el.textContent = status;
                setTimeout(() => {
                    el.textContent = 'Auto-save enabled';
                }, 2000);
            }
        }

        // Auto-save after each agent execution
        const originalLoadProjectPipeline = loadProjectPipeline;
        loadProjectPipeline = async function() {
            await originalLoadProjectPipeline();

            // Auto-save to localStorage after loading
            if (currentProject && projectData) {
                try {
                    const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                    if (res.ok) {
                        const data = await res.json();
                        saveToLocalStorage(data);
                    }
                } catch (error) {
                    console.error('Auto-save error:', error);
                }
            }

            // Update chapter writer section
            await updateChapterWriter();
        };

        // =================================================================
        // Export Functions
        // =================================================================

        async function exportOutline() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/outline`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export outline error:', error);
                alert('Failed to export outline. Make sure the pipeline has been run.');
            }
        }

        async function exportManuscript() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/manuscript`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export manuscript error:', error);
                alert('Failed to export manuscript');
            }
        }

        function downloadMarkdown(filename, content) {
            const blob = new Blob([content], {type: 'text/markdown'});
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportDocx() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating Word document...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/docx`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.docx';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'Word document downloaded!';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export DOCX error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export Word document: ' + error.message);
            }
        }

        async function exportEpub() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating EPUB for Kindle...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/epub`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.epub';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'EPUB downloaded! Ready for Kindle.';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export EPUB error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export EPUB: ' + error.message);
            }
        }

        // =================================================================
        // Chapter Writer Functions
        // =================================================================

        let writtenChapters = {};
        let chapterBlueprint = null;

        async function updateChapterWriter() {
            if (!currentProject || !projectData) return;

            const statusEl = document.getElementById('chapterWriterStatus');
            const listEl = document.getElementById('chapterList');
            const writeAllBtn = document.getElementById('writeAllChaptersBtn');

            // Check if chapter_blueprint agent has passed
            let blueprintPassed = false;
            chapterBlueprint = null;

            for (const [layerId, layer] of Object.entries(projectData.layers)) {
                if (layer.agents && layer.agents.chapter_blueprint) {
                    const agent = layer.agents.chapter_blueprint;
                    if (agent.status === 'passed' && agent.output) {
                        blueprintPassed = true;
                        chapterBlueprint = agent.output.content;
                        break;
                    }
                }
            }

            if (!blueprintPassed) {
                statusEl.innerHTML = '<span style="color:#f39c12;">Complete Layer 10 (Chapter Blueprint) first</span>';
                listEl.innerHTML = '';
                writeAllBtn.disabled = true;
                return;
            }

            // Get written chapters
            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters`, {credentials: 'include'});
                if (res.ok) {
                    const data = await res.json();
                    writtenChapters = {};
                    data.chapters.forEach(ch => {
                        writtenChapters[ch.number] = ch;
                    });
                }
            } catch (error) {
                console.error('Failed to load chapters:', error);
            }

            // Render chapter list
            const chapters = chapterBlueprint.chapter_outline || [];
            const totalChapters = chapters.length;
            const writtenCount = Object.keys(writtenChapters).length;

            statusEl.innerHTML = `<span style="color:#2ecc71;">${writtenCount} / ${totalChapters} chapters written</span>`;
            writeAllBtn.disabled = false;

            listEl.innerHTML = chapters.map(ch => {
                const isWritten = writtenChapters[ch.number];
                const className = isWritten ? 'chapter-item written' : 'chapter-item';
                const icon = isWritten ? '✓' : '○';
                return `<span class="${className}" onclick="writeChapter(${ch.number})" title="${ch.title}">${icon} Ch ${ch.number}</span>`;
            }).join('');
        }

        async function writeChapter(chapterNumber) {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const chapterItem = document.querySelector(`.chapter-item[onclick="writeChapter(${chapterNumber})"]`);
            if (chapterItem) {
                chapterItem.classList.add('writing');
                chapterItem.classList.remove('written');
            }

            document.getElementById('chapterWriteProgress').textContent = `Writing Chapter ${chapterNumber}...`;

            try {
                const res = await fetch(`/api/projects/${currentProject}/write-chapter/${chapterNumber}`, {
                    method: 'POST',
                    credentials: 'include'
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Failed to write chapter');
                }

                const data = await res.json();

                if (data.success && data.chapter) {
                    writtenChapters[chapterNumber] = data.chapter;

                    // Update UI
                    if (chapterItem) {
                        chapterItem.classList.remove('writing');
                        chapterItem.classList.add('written');
                        chapterItem.innerHTML = `✓ Ch ${chapterNumber}`;
                    }

                    // Show chapter preview
                    document.getElementById('chapterPreview').classList.remove('hidden');
                    document.getElementById('chapterText').textContent =
                        `Chapter ${chapterNumber}: ${data.chapter.title}\n` +
                        `Words: ${data.chapter.word_count}\n\n` +
                        (data.chapter.text || 'No text generated');

                    document.getElementById('chapterWriteProgress').textContent = `Chapter ${chapterNumber} complete!`;
                }

                await updateChapterWriter();
            } catch (error) {
                console.error('Write chapter error:', error);
                alert('Failed to write chapter: ' + error.message);

                if (chapterItem) {
                    chapterItem.classList.remove('writing');
                }
                document.getElementById('chapterWriteProgress').textContent = 'Error writing chapter';
            }
        }

        let isWritingAllChapters = false;
        let chapterWriteRetries = 0;
        const MAX_CHAPTER_RETRIES = 50; // Allow many retries for 20 chapters

        // Auto-write chapters with timeout-aware batch processing and auto-resume
        async function autoWriteAllChapters() {
            if (!currentProject) return;

            // Refresh chapter writer data
            await updateChapterWriter();

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                console.log('No chapter blueprint available yet');
                return;
            }

            const totalChapters = chapterBlueprint.chapter_outline.length;
            console.log(`Starting auto-write for ${totalChapters} chapters...`);
            document.getElementById('progressStatus').textContent = `Writing chapters...`;

            const btn = document.getElementById('runFullPipelineBtn');
            btn.innerHTML = '<span class="running-indicator"></span>Writing Chapters...';

            isWritingAllChapters = true;
            chapterWriteRetries = 0;

            try {
                let shouldContinue = true;
                let consecutiveFailures = 0;

                while (shouldContinue && chapterWriteRetries < MAX_CHAPTER_RETRIES) {
                    chapterWriteRetries++;

                    document.getElementById('progressStatus').textContent =
                        `Writing chapters... (batch ${chapterWriteRetries})`;

                    try {
                        // Call batch endpoint - writes one chapter at a time to stay under timeout
                        // quick_mode: true writes ~500 word preview chapters (faster, works on Vercel)
                        // quick_mode: false writes full ~3000 word chapters (requires longer timeout)
                        const res = await fetch(`/api/projects/${currentProject}/write-chapters-batch`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({
                                timeout_seconds: 55,  // Use most of 60s limit
                                max_chapters: 1,      // One chapter per request
                                quick_mode: true      // Preview mode for Vercel (faster generation)
                            })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            consecutiveFailures = 0; // Reset on success

                            if (data.chapters_written && data.chapters_written.length > 0) {
                                console.log(`Batch ${chapterWriteRetries}: Wrote chapters ${data.chapters_written.join(', ')}`);
                                document.getElementById('chapterWriteProgress').textContent =
                                    `Completed ${data.completed_count} of ${data.total_chapters} chapters`;
                            }

                            if (data.chapters_failed && data.chapters_failed.length > 0) {
                                console.warn('Some chapters failed:', data.chapters_failed);
                            }

                            shouldContinue = data.should_continue;

                            if (!shouldContinue) {
                                console.log('All chapters written!');
                                document.getElementById('progressStatus').textContent = 'Book Complete!';
                                document.getElementById('chapterWriteProgress').textContent =
                                    `All ${data.total_chapters} chapters written!`;
                            }

                            // Update UI after each batch
                            await updateChapterWriter();

                        } else {
                            consecutiveFailures++;
                            console.error(`Batch ${chapterWriteRetries} failed with status ${res.status}`);

                            // If server error, wait and retry
                            if (res.status >= 500 && consecutiveFailures < 5) {
                                const waitTime = Math.min(consecutiveFailures * 2000, 10000);
                                console.log(`Waiting ${waitTime}ms before retry...`);
                                document.getElementById('progressStatus').textContent =
                                    `Server busy, retrying in ${waitTime/1000}s...`;
                                await new Promise(r => setTimeout(r, waitTime));
                            } else if (consecutiveFailures >= 5) {
                                console.error('Too many consecutive failures, stopping');
                                shouldContinue = false;
                            }
                        }

                    } catch (err) {
                        consecutiveFailures++;
                        console.error(`Batch ${chapterWriteRetries} error:`, err);

                        // Network error - wait and retry
                        if (consecutiveFailures < 5) {
                            const waitTime = Math.min(consecutiveFailures * 2000, 10000);
                            console.log(`Network error, waiting ${waitTime}ms before retry...`);
                            document.getElementById('progressStatus').textContent =
                                `Connection issue, retrying in ${waitTime/1000}s...`;
                            await new Promise(r => setTimeout(r, waitTime));
                        } else {
                            console.error('Too many consecutive failures, stopping');
                            shouldContinue = false;
                        }
                    }

                    // Small delay between batches to be nice to the server
                    if (shouldContinue) {
                        await new Promise(r => setTimeout(r, 1000));
                    }
                }

                if (chapterWriteRetries >= MAX_CHAPTER_RETRIES) {
                    console.warn('Reached max retries');
                    document.getElementById('progressStatus').textContent = 'Writing paused - refresh to continue';
                }

                // Final update
                await loadProjectPipeline();

            } catch (error) {
                console.error('Auto-write chapters error:', error);
            } finally {
                isWritingAllChapters = false;
            }
        }

        async function writeAllChapters() {
            if (!currentProject || isWritingAllChapters) return;

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                alert('Chapter blueprint not available');
                return;
            }

            const chapters = chapterBlueprint.chapter_outline;
            const unwritten = chapters.filter(ch => !writtenChapters[ch.number]);

            if (unwritten.length === 0) {
                alert('All chapters have already been written!');
                return;
            }

            if (!confirm(`This will write ${unwritten.length} chapters. This may take several minutes. Continue?`)) {
                return;
            }

            isWritingAllChapters = true;
            const btn = document.getElementById('writeAllChaptersBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Writing...';

            try {
                for (let i = 0; i < unwritten.length; i++) {
                    const ch = unwritten[i];
                    document.getElementById('chapterWriteProgress').textContent =
                        `Writing chapter ${ch.number} (${i + 1}/${unwritten.length})...`;

                    await writeChapter(ch.number);

                    // Small delay between chapters
                    await new Promise(r => setTimeout(r, 1000));
                }

                document.getElementById('chapterWriteProgress').textContent = 'All chapters complete!';
                alert('All chapters have been written!');
            } catch (error) {
                console.error('Write all chapters error:', error);
                alert('Error during chapter writing: ' + error.message);
            } finally {
                isWritingAllChapters = false;
                btn.disabled = false;
                btn.innerHTML = 'Write All Chapters';
            }
        }

        async function viewWrittenChapter(chapterNumber) {
            if (!currentProject) return;

            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters/${chapterNumber}`, {credentials: 'include'});
                if (!res.ok) throw new Error('Chapter not found');

                const chapter = await res.json();

                document.getElementById('chapterPreview').classList.remove('hidden');
                document.getElementById('chapterText').textContent =
                    `Chapter ${chapter.number}: ${chapter.title}\n` +
                    `Words: ${chapter.word_count}\n\n` +
                    (chapter.text || 'No text');
            } catch (error) {
                console.error('View chapter error:', error);
            }
        }

        checkAuth();
    </script>
</body>
</html>
