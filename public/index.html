<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Million Dollar Book Machine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            min-height: 100vh;
            color: #e4e4e4;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 1rem; }

        /* Login */
        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .login-card {
            background: rgba(255,255,255,0.05);
            padding: 2rem;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }
        .login-card h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 1rem;
        }
        .header h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.5rem;
        }

        /* Forms */
        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        label { display: block; margin-bottom: 0.25rem; color: #888; font-size: 0.9rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }
        .btn-danger { background: rgba(231,76,60,0.2); color: #e74c3c; }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card h2 { color: #00d4ff; margin-bottom: 1rem; font-size: 1.2rem; }
        .card h3 { color: #888; margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; }

        /* Grid */
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
        @media (max-width: 768px) {
            .grid-2, .grid-3 { grid-template-columns: 1fr; }
        }

        /* Pipeline View */
        .pipeline { display: flex; flex-direction: column; gap: 0.5rem; }
        .layer {
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid #333;
        }
        .layer.available { border-left-color: #00d4ff; }
        .layer.in-progress { border-left-color: #f39c12; }
        .layer.completed { border-left-color: #2ecc71; }
        .layer.locked { opacity: 0.5; }
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .layer-name { font-weight: 600; }
        .layer-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        .agents { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem; }
        .agent {
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.2s;
        }
        .agent:hover { background: rgba(0,212,255,0.2); }
        .agent.passed { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .agent.failed { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .agent.running { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Output Panel */
        .output-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }
        .output-panel pre {
            font-family: monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            color: #00d4ff;
        }

        /* Tabs */
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        .tab {
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
        }
        .tab.active { background: linear-gradient(90deg, #00d4ff, #7b2cbf); }

        /* Hidden */
        .hidden { display: none !important; }

        /* API Status Indicator */
        .api-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .api-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            animation: pulse 2s infinite;
        }
        .api-status.active .api-status-dot {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46,204,113,0.5);
        }
        .api-status.inactive .api-status-dot {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231,76,60,0.5);
            animation: none;
        }
        .api-status.active {
            border-color: rgba(46,204,113,0.3);
            background: rgba(46,204,113,0.1);
        }
        .api-status.inactive {
            border-color: rgba(231,76,60,0.3);
            background: rgba(231,76,60,0.1);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stat { text-align: center; padding: 1rem; }
        .stat-value { font-size: 2rem; font-weight: 700; color: #00d4ff; }
        .stat-label { font-size: 0.8rem; color: #888; }

        /* Progress Bar */
        .progress-container {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .progress-title { font-weight: 600; font-size: 1.1rem; }
        .progress-percent { color: #00d4ff; font-weight: 700; font-size: 1.2rem; }
        .progress-bar {
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        .progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #888;
        }

        /* Run Full Button */
        .btn-full-pipeline {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            color: #fff;
            width: 100%;
            padding: 1rem;
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .btn-full-pipeline:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(46,204,113,0.3); }
        .btn-full-pipeline:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Running State */
        .running-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Save/Load Buttons */
        .btn-save { background: linear-gradient(90deg, #3498db, #2980b9); color: #fff; }
        .btn-load { background: rgba(52,152,219,0.2); color: #3498db; border: 1px solid #3498db; }
        .btn-export { background: linear-gradient(90deg, #9b59b6, #8e44ad); color: #fff; }
        .btn-write { background: linear-gradient(90deg, #e67e22, #d35400); color: #fff; }
        .file-input-hidden { display: none; }
        .save-load-section {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .auto-save-indicator {
            font-size: 0.75rem;
            color: #2ecc71;
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .auto-save-indicator::before {
            content: "●";
            font-size: 0.5rem;
        }

        /* Chapter Writer Section */
        .chapter-writer-section {
            background: rgba(230,126,34,0.1);
            border: 1px solid rgba(230,126,34,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .chapter-writer-section h3 {
            color: #e67e22;
            margin-bottom: 0.75rem;
        }
        .chapter-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .chapter-item {
            padding: 0.5rem 0.75rem;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .chapter-item:hover { background: rgba(230,126,34,0.2); }
        .chapter-item.written { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .chapter-item.writing { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Export Section */
        .export-section {
            background: rgba(155,89,182,0.1);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .export-section h3 {
            color: #9b59b6;
            margin-bottom: 0.75rem;
        }
        .export-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Theme Development Styles */
        .theme-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            margin-bottom: 1rem;
            overflow: hidden;
        }
        .theme-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(155,89,182,0.1);
            cursor: pointer;
            transition: background 0.2s;
        }
        .theme-header:hover {
            background: rgba(155,89,182,0.2);
        }
        .theme-name {
            font-weight: 600;
            color: #9b59b6;
            font-size: 1.1rem;
        }
        .theme-toggle {
            color: #888;
            font-size: 1.2rem;
            transition: transform 0.2s;
        }
        .theme-card.expanded .theme-toggle {
            transform: rotate(180deg);
        }
        .theme-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        .theme-card.expanded .theme-content {
            padding: 1rem;
            max-height: 1000px;
        }
        .theme-field {
            margin-bottom: 1rem;
        }
        .theme-field label {
            display: block;
            color: #9b59b6;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        .theme-field textarea {
            min-height: 80px;
            resize: vertical;
        }
        .theme-field input, .theme-field textarea {
            margin-bottom: 0;
        }
        .theme-delete {
            color: #e74c3c;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }
        .theme-delete:hover {
            background: rgba(231,76,60,0.2);
            border-radius: 4px;
        }
        .theme-examples {
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: #888;
        }
        .theme-examples strong {
            color: #9b59b6;
        }

        /* Image Generation Styles */
        .image-gen-section {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 1rem;
        }
        .image-preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
        }
        .image-preview-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            background: rgba(0,0,0,0.3);
        }
        .image-preview-item:hover {
            transform: scale(1.05);
        }
        .image-preview-item img {
            width: 100%;
            height: auto;
            display: block;
        }
        .image-preview-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.7);
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            color: #fff;
            text-align: center;
        }
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .image-modal-content {
            max-width: 90vw;
            max-height: 90vh;
            background: #1a1a3e;
            border-radius: 12px;
            overflow: hidden;
        }
        .image-modal-content img {
            max-width: 100%;
            max-height: 70vh;
            display: block;
        }
        .image-modal-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2rem;
            color: #fff;
            cursor: pointer;
            z-index: 1001;
        }
        .image-placeholder {
            width: 100%;
            aspect-ratio: 3/4;
            background: rgba(255,255,255,0.05);
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Screen -->
        <div class="login-screen" id="loginScreen">
            <div class="login-card">
                <h1>Million Dollar Book Machine</h1>
                <p style="color:#888;margin-bottom:2rem;">AI-Powered Book Development</p>
                <form id="loginForm">
                    <input type="password" id="password" placeholder="Enter password" required>
                    <button type="submit" class="btn btn-primary" style="width:100%">Sign In</button>
                </form>
                <p id="loginError" class="hidden" style="color:#e74c3c;margin-top:1rem;">Invalid password</p>
            </div>
        </div>

        <!-- Main App -->
        <div id="appContent" class="hidden">
            <div class="header">
                <h1>Million Dollar Book Machine</h1>
                <div style="display:flex;align-items:center;gap:1rem;">
                    <div id="apiStatus" class="api-status">
                        <span class="api-status-dot"></span>
                        <span class="api-status-text">Checking API...</span>
                    </div>
                    <button class="btn btn-danger btn-small" onclick="logout()">Sign Out</button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <div class="tab active" onclick="showTab('projects')">Projects</div>
                <div class="tab" onclick="showTab('newProject')">New Project</div>
                <div class="tab" onclick="showTab('pipeline')">Pipeline</div>
                <div class="tab" onclick="showTab('themes')">Themes</div>
                <div class="tab" onclick="showTab('images')">Images</div>
            </div>

            <!-- Projects Tab -->
            <div id="projectsTab">
                <div class="card">
                    <h2>Your Projects</h2>
                    <div id="projectsList"></div>
                    <div class="save-load-section">
                        <button class="btn btn-load btn-small" onclick="document.getElementById('importFile').click()">
                            Import Project
                        </button>
                        <input type="file" id="importFile" class="file-input-hidden" accept=".json" onchange="importProject(event)">
                        <button class="btn btn-secondary btn-small" onclick="restoreFromLocalStorage()">
                            Restore from Browser
                        </button>
                        <span class="auto-save-indicator" id="autoSaveStatus">Auto-save enabled</span>
                    </div>
                </div>
            </div>

            <!-- New Project Tab -->
            <div id="newProjectTab" class="hidden">
                <div class="card">
                    <h2>Create New Book Project</h2>
                    <form id="newProjectForm">
                        <div class="grid-2">
                            <div>
                                <label>Book Title *</label>
                                <input type="text" id="projectTitle" required placeholder="Your book title">
                            </div>
                            <div>
                                <label>Genre *</label>
                                <select id="projectGenre" required>
                                    <option value="">Select genre</option>
                                    <option value="literary_fiction">Literary Fiction</option>
                                    <option value="thriller">Thriller</option>
                                    <option value="mystery">Mystery</option>
                                    <option value="romance">Romance</option>
                                    <option value="sci_fi">Science Fiction</option>
                                    <option value="fantasy">Fantasy</option>
                                    <option value="horror">Horror</option>
                                    <option value="memoir">Memoir</option>
                                    <option value="self_help">Self-Help</option>
                                    <option value="business">Business</option>
                                </select>
                            </div>
                        </div>
                        <label>Book Description / Vision</label>
                        <textarea id="projectDescription" rows="4" placeholder="Describe your book idea..."></textarea>
                        <div class="grid-2">
                            <div>
                                <label>Target Word Count</label>
                                <input type="number" id="projectWordCount" value="80000">
                            </div>
                            <div>
                                <label>Target Audience</label>
                                <input type="text" id="projectAudience" placeholder="e.g., Adults 25-45">
                            </div>
                        </div>
                        <label>Comparable Titles (comma separated)</label>
                        <input type="text" id="projectComps" placeholder="e.g., The Alchemist, Atomic Habits">
                        <label>Themes (comma separated)</label>
                        <input type="text" id="projectThemes" placeholder="e.g., redemption, identity, love">
                        <button type="submit" class="btn btn-primary">Create Project</button>
                    </form>
                </div>
            </div>

            <!-- Themes Tab -->
            <div id="themesTab" class="hidden">
                <div id="noThemeProject" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to develop its themes</p>
                </div>
                <div id="themesView" class="hidden">
                    <div class="card">
                        <h2 id="themesProjectTitle">Theme Development</h2>
                        <p style="color:#888;margin-bottom:1rem;">Expand each theme to develop its meaning, manifestation in the story, and symbolic elements.</p>

                        <div id="themesList"></div>

                        <div style="margin-top:1rem;padding-top:1rem;border-top:1px solid rgba(255,255,255,0.1);">
                            <h3 style="color:#888;margin-bottom:0.5rem;">Add New Theme</h3>
                            <div style="display:flex;gap:0.5rem;">
                                <input type="text" id="newThemeName" placeholder="Theme name (e.g., redemption)" style="flex:1;margin-bottom:0;">
                                <button class="btn btn-primary btn-small" onclick="addNewTheme()">Add Theme</button>
                            </div>
                        </div>

                        <div style="margin-top:1rem;">
                            <button class="btn btn-save btn-small" onclick="saveThemes()">Save All Themes</button>
                            <button class="btn btn-secondary btn-small" onclick="generateThemeIdeas()">AI: Generate Theme Ideas</button>
                            <span id="themeSaveStatus" style="margin-left:0.5rem;font-size:0.85rem;color:#888;"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Images Tab -->
            <div id="imagesTab" class="hidden">
                <div id="noImageProject" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to generate images</p>
                </div>
                <div id="imagesView" class="hidden">
                    <!-- API Status Banner -->
                    <div id="imageApiStatus" class="card" style="margin-bottom:1rem;">
                        <div style="display:flex;align-items:center;gap:0.5rem;">
                            <span id="imageApiDot" style="width:10px;height:10px;border-radius:50%;background:#888;"></span>
                            <span id="imageApiText">Checking image generation status...</span>
                        </div>
                    </div>

                    <!-- Visual Analysis Status -->
                    <div id="visualAnalysisStatus" class="card" style="margin-bottom:1rem;background:rgba(155,89,182,0.1);">
                        <h3 style="color:#9b59b6;margin-bottom:0.5rem;">Story Analysis for Images</h3>
                        <p style="color:#888;font-size:0.85rem;margin-bottom:0.5rem;">
                            Images are generated using data from your book's pipeline. Run more agents to get richer, more accurate artwork.
                        </p>
                        <div id="visualDataChecklist" style="display:grid;grid-template-columns:repeat(3,1fr);gap:0.5rem;font-size:0.85rem;">
                            <span id="vd_protagonist" style="color:#888;">&#x2610; Protagonist</span>
                            <span id="vd_setting" style="color:#888;">&#x2610; Setting</span>
                            <span id="vd_mood" style="color:#888;">&#x2610; Mood/Tone</span>
                            <span id="vd_themes" style="color:#888;">&#x2610; Themes</span>
                            <span id="vd_symbols" style="color:#888;">&#x2610; Symbols</span>
                            <span id="vd_hook" style="color:#888;">&#x2610; Story Hook</span>
                        </div>
                        <button class="btn btn-secondary btn-small" onclick="viewFullAnalysis()" style="margin-top:0.75rem;">View Full Analysis</button>
                    </div>

                    <div class="grid-2">
                        <!-- Cover Generation -->
                        <div class="card">
                            <h2 style="color:#e67e22;">Book Covers</h2>
                            <p style="color:#888;margin-bottom:1rem;">Generate AI-powered cover art for your book</p>

                            <div class="image-gen-section">
                                <label>Cover Style</label>
                                <select id="coverStyle">
                                    <option value="professional cinematic book cover">Cinematic (Recommended)</option>
                                    <option value="minimalist modern book cover">Minimalist Modern</option>
                                    <option value="illustrated artistic book cover">Illustrated/Artistic</option>
                                    <option value="dramatic dark moody book cover">Dark & Moody</option>
                                    <option value="vibrant colorful book cover">Vibrant & Colorful</option>
                                    <option value="vintage classic book cover">Vintage Classic</option>
                                </select>

                                <div style="display:flex;gap:0.5rem;margin-top:1rem;">
                                    <button class="btn btn-write btn-small" onclick="generateCover('front')" id="genFrontBtn">
                                        Generate Front Cover
                                    </button>
                                    <button class="btn btn-secondary btn-small" onclick="generateCover('back')" id="genBackBtn">
                                        Generate Back Cover
                                    </button>
                                </div>

                                <p id="coverGenStatus" style="font-size:0.85rem;color:#888;margin-top:0.5rem;"></p>
                            </div>

                            <!-- Cover Previews -->
                            <div style="margin-top:1rem;">
                                <h3 style="color:#888;margin-bottom:0.5rem;">Generated Covers</h3>
                                <div class="image-preview-grid" id="coverPreviews">
                                    <p style="color:#666;font-size:0.85rem;">No covers generated yet</p>
                                </div>
                            </div>
                        </div>

                        <!-- Chapter Illustrations -->
                        <div class="card">
                            <h2 style="color:#9b59b6;">Chapter Illustrations</h2>
                            <p style="color:#888;margin-bottom:1rem;">Generate illustrations for each chapter</p>

                            <div class="image-gen-section">
                                <label>Illustration Style</label>
                                <select id="chapterStyle">
                                    <option value="moody atmospheric illustration">Atmospheric (Recommended)</option>
                                    <option value="detailed realistic illustration">Realistic</option>
                                    <option value="stylized artistic illustration">Stylized Art</option>
                                    <option value="noir black and white illustration">Noir B&W</option>
                                    <option value="watercolor soft illustration">Watercolor</option>
                                    <option value="dramatic cinematic scene">Cinematic Scene</option>
                                </select>

                                <label style="margin-top:1rem;">Select Chapter</label>
                                <select id="chapterSelect">
                                    <option value="">-- Select a chapter --</option>
                                </select>

                                <div style="margin-top:1rem;">
                                    <button class="btn btn-export btn-small" onclick="generateChapterImage()" id="genChapterBtn">
                                        Generate Chapter Illustration
                                    </button>
                                    <button class="btn btn-secondary btn-small" onclick="generateAllChapterImages()" id="genAllChaptersBtn">
                                        Generate All
                                    </button>
                                </div>

                                <p id="chapterGenStatus" style="font-size:0.85rem;color:#888;margin-top:0.5rem;"></p>
                            </div>

                            <!-- Chapter Image Previews -->
                            <div style="margin-top:1rem;">
                                <h3 style="color:#888;margin-bottom:0.5rem;">Chapter Images</h3>
                                <div class="image-preview-grid" id="chapterPreviews">
                                    <p style="color:#666;font-size:0.85rem;">No chapter images generated yet</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Full Image Preview Modal -->
                    <div id="imageModal" class="image-modal hidden" onclick="closeImageModal()">
                        <div class="image-modal-content" onclick="event.stopPropagation()">
                            <span class="image-modal-close" onclick="closeImageModal()">&times;</span>
                            <img id="modalImage" src="" alt="Preview">
                            <div id="modalInfo" style="padding:1rem;color:#888;"></div>
                            <div style="padding:0 1rem 1rem;">
                                <button class="btn btn-primary btn-small" onclick="downloadCurrentImage()">Download</button>
                                <button class="btn btn-danger btn-small" onclick="deleteCurrentImage()">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pipeline Tab -->
            <div id="pipelineTab" class="hidden">
                <div id="noProjectSelected" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to view its pipeline</p>
                </div>
                <div id="pipelineView" class="hidden">
                    <!-- Progress Bar -->
                    <div class="progress-container">
                        <div class="progress-header">
                            <span class="progress-title" id="progressTitle">Book Development Progress</span>
                            <span class="progress-percent" id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-details">
                            <span id="progressStatus">Ready to start</span>
                            <span id="progressAgents">0 / 0 agents completed</span>
                        </div>
                        <button class="btn btn-full-pipeline" id="runFullPipelineBtn" onclick="runFullPipeline()">
                            Run Full Pipeline
                        </button>
                    </div>

                    <div class="grid-3" style="margin-bottom:1rem;">
                        <div class="card stat">
                            <div class="stat-value" id="statLayers">0</div>
                            <div class="stat-label">Layers</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statAgents">0</div>
                            <div class="stat-label">Agents</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statCompleted">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                    </div>

                    <div class="grid-2">
                        <div class="card">
                            <h2 id="pipelineProjectTitle">Pipeline</h2>
                            <div class="pipeline" id="pipelineLayers"></div>
                            <div style="margin-top:1rem;">
                                <button class="btn btn-primary btn-small" id="runNextBtn" onclick="runNextAgent()">Run Next Agent</button>
                                <button class="btn btn-secondary btn-small" id="runAvailableBtn" onclick="runAllAvailable()">Run All Available</button>
                                <button class="btn btn-save btn-small" onclick="exportProject()">Save Project</button>
                            </div>

                            <!-- Export Section -->
                            <div class="export-section">
                                <h3>Export Documents</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.75rem;">Download your book in different formats</p>
                                <div class="export-buttons">
                                    <button class="btn btn-export btn-small" onclick="exportDocx()">Word Document (.docx)</button>
                                    <button class="btn btn-export btn-small" onclick="exportEpub()">Kindle/EPUB (.epub)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportOutline()">Outline (MD)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportManuscript()">Manuscript (MD)</button>
                                </div>
                                <p id="exportStatus" style="font-size:0.8rem;color:#888;margin-top:0.5rem;"></p>
                            </div>

                            <!-- Chapter Writer Section -->
                            <div class="chapter-writer-section" id="chapterWriterSection">
                                <h3>Chapter Writer</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.5rem;">Write individual chapters after completing Layer 10 (Chapter Blueprint)</p>
                                <div id="chapterWriterStatus"></div>
                                <div class="chapter-list" id="chapterList"></div>
                                <div style="margin-top:0.75rem;">
                                    <button class="btn btn-write btn-small" id="writeAllChaptersBtn" onclick="writeAllChapters()">Write All Chapters</button>
                                    <span id="chapterWriteProgress" style="margin-left:0.5rem;font-size:0.85rem;color:#888;"></span>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <h2>Agent Output</h2>
                            <p id="selectedAgentName" style="color:#888;margin-bottom:0.5rem;">Select an agent to view output</p>
                            <div class="output-panel">
                                <pre id="agentOutput">No output yet</pre>
                            </div>

                            <!-- Chapter Preview -->
                            <div id="chapterPreview" class="hidden" style="margin-top:1rem;">
                                <h3 style="color:#e67e22;margin-bottom:0.5rem;">Chapter Preview</h3>
                                <div class="output-panel" style="max-height:300px;">
                                    <pre id="chapterText" style="white-space:pre-wrap;color:#fff;"></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentProject = null;
        let projectData = null;

        // =================================================================
        // Auto-restore helper for stateless serverless
        // =================================================================

        async function ensureProjectOnServer(projectId) {
            // Check if project exists on server
            const res = await fetch(`/api/projects/${projectId}`, {credentials: 'include'});

            if (res.ok) {
                return true; // Project exists
            }

            if (res.status === 404) {
                // Try to restore from localStorage
                const saved = getLocalStorageProjects();
                const project = saved[projectId];

                if (project) {
                    console.log('Auto-restoring project from localStorage...');
                    try {
                        const importRes = await fetch('/api/projects/import', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            credentials: 'include',
                            body: JSON.stringify(project)
                        });

                        if (importRes.ok) {
                            console.log('Project restored successfully');
                            return true;
                        }
                    } catch (error) {
                        console.error('Failed to restore project:', error);
                    }
                }
            }

            return false;
        }

        // Auth
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const res = await fetch('/api/auth/login', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify({password: document.getElementById('password').value})
            });
            if (res.ok) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            } else {
                document.getElementById('loginError').classList.remove('hidden');
            }
        });

        async function logout() {
            await fetch('/api/auth/logout', {method: 'POST', credentials: 'include'});
            location.reload();
        }

        async function checkAuth() {
            const res = await fetch('/api/auth/check', {credentials: 'include'});
            const data = await res.json();
            if (data.authenticated) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            }
        }

        // API Status Check
        async function checkApiStatus() {
            const statusEl = document.getElementById('apiStatus');
            const dotEl = statusEl.querySelector('.api-status-dot');
            const textEl = statusEl.querySelector('.api-status-text');

            try {
                const res = await fetch('/api/system/llm-status', {credentials: 'include'});
                const data = await res.json();

                if (data.enabled) {
                    statusEl.className = 'api-status active';
                    textEl.textContent = `API Active (${data.model || 'Claude'})`;
                } else {
                    statusEl.className = 'api-status inactive';
                    textEl.textContent = 'API Inactive - Demo Mode';
                    console.warn('API Status:', data.message);
                }
            } catch (error) {
                statusEl.className = 'api-status inactive';
                textEl.textContent = 'API Error';
                console.error('API Status Error:', error);
            }
        }

        // Refresh API status periodically
        setInterval(checkApiStatus, 60000); // Check every minute

        // Tabs
        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="showTab('${tab}')"]`).classList.add('active');
            document.getElementById('projectsTab').classList.add('hidden');
            document.getElementById('newProjectTab').classList.add('hidden');
            document.getElementById('pipelineTab').classList.add('hidden');
            document.getElementById('themesTab').classList.add('hidden');
            document.getElementById('imagesTab').classList.add('hidden');
            document.getElementById(tab + 'Tab').classList.remove('hidden');

            // Load themes when switching to themes tab
            if (tab === 'themes') {
                loadThemesView();
            }

            // Load images when switching to images tab
            if (tab === 'images') {
                loadImagesView();
            }
        }

        // Projects
        async function loadProjects() {
            const res = await fetch('/api/projects', {credentials: 'include'});
            const data = await res.json();
            const container = document.getElementById('projectsList');

            if (data.projects.length === 0) {
                container.innerHTML = '<p style="color:#888;">No projects yet. Create your first book!</p>';
            } else {
                container.innerHTML = data.projects.map(p => `
                    <div class="card" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <div>
                            <strong>${p.title}</strong>
                            <span style="color:#888;margin-left:1rem;">${p.status}</span>
                        </div>
                        <button class="btn btn-primary btn-small" onclick="selectProject('${p.project_id}')">Open</button>
                    </div>
                `).join('');
            }
        }

        async function selectProject(projectId) {
            currentProject = projectId;
            await loadProjectPipeline();
            showTab('pipeline');
        }

        async function loadProjectPipeline() {
            if (!currentProject) return;

            // Ensure project exists on server (auto-restore if needed)
            const exists = await ensureProjectOnServer(currentProject);
            if (!exists) {
                alert('Project not found. Please create a new project.');
                currentProject = null;
                showTab('projects');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}`, {credentials: 'include'});
            projectData = await res.json();

            document.getElementById('noProjectSelected').classList.add('hidden');
            document.getElementById('pipelineView').classList.remove('hidden');
            document.getElementById('pipelineProjectTitle').textContent = projectData.title;

            // Stats
            const layers = Object.keys(projectData.layers).length;
            let agents = 0, completed = 0;
            Object.values(projectData.layers).forEach(l => {
                Object.values(l.agents).forEach(a => {
                    agents++;
                    if (a.status === 'passed') completed++;
                });
            });
            document.getElementById('statLayers').textContent = layers;
            document.getElementById('statAgents').textContent = agents;
            document.getElementById('statCompleted').textContent = completed;

            // Update progress bar
            const percent = agents > 0 ? Math.round((completed / agents) * 100) : 0;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressAgents').textContent = `${completed} / ${agents} agents completed`;

            // Update progress status
            let status = 'Ready to start';
            if (completed === agents && agents > 0) {
                status = 'Pipeline complete!';
                document.getElementById('runFullPipelineBtn').textContent = 'Pipeline Complete';
                document.getElementById('runFullPipelineBtn').disabled = true;
            } else if (completed > 0) {
                const currentLayer = projectData.current_layer || 0;
                status = `Layer ${currentLayer} in progress`;
            }
            document.getElementById('progressStatus').textContent = status;

            // Render pipeline
            const container = document.getElementById('pipelineLayers');
            container.innerHTML = '';

            Object.entries(projectData.layers).sort((a,b) => a[0] - b[0]).forEach(([layerId, layer]) => {
                const div = document.createElement('div');
                div.className = `layer ${layer.status}`;
                div.innerHTML = `
                    <div class="layer-header">
                        <span class="layer-name">Layer ${layerId}: ${layer.name}</span>
                        <span class="layer-status">${layer.status}</span>
                    </div>
                    <div class="agents">
                        ${Object.entries(layer.agents).map(([aid, a]) => `
                            <span class="agent ${a.status}" onclick="viewAgent('${aid}')" title="${a.status}">${a.status === 'passed' ? '✓' : a.status === 'failed' ? '✗' : '○'} ${aid}</span>
                        `).join('')}
                    </div>
                `;
                container.appendChild(div);
            });
        }

        async function viewAgent(agentId) {
            if (!currentProject) return;
            document.getElementById('selectedAgentName').textContent = agentId;

            const res = await fetch(`/api/projects/${currentProject}/agent/${agentId}/output`, {credentials: 'include'});
            const data = await res.json();

            if (data.output) {
                document.getElementById('agentOutput').textContent = JSON.stringify(data.output, null, 2);
            } else {
                document.getElementById('agentOutput').textContent = data.message || 'No output yet';
            }
        }

        async function runNextAgent() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            if (data.available_agents.length > 0) {
                const agent = data.available_agents[0];
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
                await loadProjectPipeline();
                viewAgent(agent.id);
            } else {
                alert('No agents available to run');
            }
        }

        async function runAllAvailable() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            for (const agent of data.available_agents) {
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
            }
            await loadProjectPipeline();
        }

        let isRunningPipeline = false;

        async function runFullPipeline() {
            if (!currentProject || isRunningPipeline) return;

            // Ensure project exists before starting
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            isRunningPipeline = true;
            const btn = document.getElementById('runFullPipelineBtn');
            const nextBtn = document.getElementById('runNextBtn');
            const availBtn = document.getElementById('runAvailableBtn');

            btn.disabled = true;
            nextBtn.disabled = true;
            availBtn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Running Pipeline...';

            try {
                let hasMore = true;
                let iterations = 0;
                const maxIterations = 100; // Safety limit

                while (hasMore && iterations < maxIterations) {
                    iterations++;

                    // Get available agents
                    const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
                    const data = await res.json();

                    if (data.available_agents.length === 0) {
                        hasMore = false;
                        break;
                    }

                    // Execute each available agent
                    for (const agent of data.available_agents) {
                        document.getElementById('progressStatus').textContent = `Running: ${agent.name}`;

                        const execRes = await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                            method: 'POST',
                            credentials: 'include'
                        });

                        if (!execRes.ok) {
                            console.error(`Failed to execute ${agent.id}`);
                        }

                        // Update progress after each agent
                        await loadProjectPipeline();
                        viewAgent(agent.id);
                    }
                }

                // Final update
                await loadProjectPipeline();

                if (iterations >= maxIterations) {
                    alert('Pipeline stopped: maximum iterations reached. Some agents may have failed.');
                } else {
                    // Pipeline complete - now automatically write all chapters
                    await autoWriteAllChapters();
                }
            } catch (error) {
                console.error('Pipeline error:', error);
                alert('An error occurred during pipeline execution. Check the console for details.');
            } finally {
                isRunningPipeline = false;
                btn.innerHTML = 'Run Full Pipeline';
                btn.disabled = false;
                nextBtn.disabled = false;
                availBtn.disabled = false;
                await loadProjectPipeline();
            }
        }

        // New Project
        document.getElementById('newProjectForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const body = {
                title: document.getElementById('projectTitle').value,
                genre: document.getElementById('projectGenre').value,
                description: document.getElementById('projectDescription').value,
                target_word_count: parseInt(document.getElementById('projectWordCount').value),
                target_audience: document.getElementById('projectAudience').value,
                comparable_titles: document.getElementById('projectComps').value.split(',').map(s => s.trim()).filter(s => s),
                themes: document.getElementById('projectThemes').value.split(',').map(s => s.trim()).filter(s => s)
            };

            const res = await fetch('/api/projects', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify(body)
            });

            if (res.ok) {
                const data = await res.json();
                currentProject = data.project_id;
                document.getElementById('newProjectForm').reset();
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
            }
        });

        // =================================================================
        // Save/Load Functions
        // =================================================================

        const STORAGE_KEY = 'million_dollar_book_projects';

        async function exportProject() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${data.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Also save to localStorage
                saveToLocalStorage(data);
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export project');
            }
        }

        async function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: text
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Import failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" imported successfully!`);
            } catch (error) {
                console.error('Import error:', error);
                alert('Failed to import project: ' + error.message);
            }

            // Reset file input
            event.target.value = '';
        }

        function saveToLocalStorage(projectData) {
            try {
                let saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                saved[projectData.project_id] = {
                    ...projectData,
                    saved_at: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
                updateAutoSaveStatus('Saved');
            } catch (error) {
                console.error('LocalStorage save error:', error);
            }
        }

        function getLocalStorageProjects() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        async function restoreFromLocalStorage() {
            const saved = getLocalStorageProjects();
            const projects = Object.values(saved);

            if (projects.length === 0) {
                alert('No saved projects found in browser storage');
                return;
            }

            // Show list of saved projects
            const choices = projects.map((p, i) =>
                `${i + 1}. ${p.title} (saved: ${new Date(p.saved_at).toLocaleString()})`
            ).join('\n');

            const choice = prompt(`Select a project to restore:\n\n${choices}\n\nEnter number:`);
            if (!choice) return;

            const index = parseInt(choice) - 1;
            if (index < 0 || index >= projects.length) {
                alert('Invalid selection');
                return;
            }

            const project = projects[index];

            try {
                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify(project)
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Restore failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" restored successfully!`);
            } catch (error) {
                console.error('Restore error:', error);
                alert('Failed to restore project: ' + error.message);
            }
        }

        function updateAutoSaveStatus(status) {
            const el = document.getElementById('autoSaveStatus');
            if (el) {
                el.textContent = status;
                setTimeout(() => {
                    el.textContent = 'Auto-save enabled';
                }, 2000);
            }
        }

        // Auto-save after each agent execution
        const originalLoadProjectPipeline = loadProjectPipeline;
        loadProjectPipeline = async function() {
            await originalLoadProjectPipeline();

            // Auto-save to localStorage after loading
            if (currentProject && projectData) {
                try {
                    const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                    if (res.ok) {
                        const data = await res.json();
                        saveToLocalStorage(data);
                    }
                } catch (error) {
                    console.error('Auto-save error:', error);
                }
            }

            // Update chapter writer section
            await updateChapterWriter();
        };

        // =================================================================
        // Export Functions
        // =================================================================

        async function exportOutline() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/outline`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export outline error:', error);
                alert('Failed to export outline. Make sure the pipeline has been run.');
            }
        }

        async function exportManuscript() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/manuscript`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export manuscript error:', error);
                alert('Failed to export manuscript');
            }
        }

        function downloadMarkdown(filename, content) {
            const blob = new Blob([content], {type: 'text/markdown'});
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportDocx() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating Word document...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/docx`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.docx';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'Word document downloaded!';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export DOCX error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export Word document: ' + error.message);
            }
        }

        async function exportEpub() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating EPUB for Kindle...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/epub`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.epub';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'EPUB downloaded! Ready for Kindle.';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export EPUB error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export EPUB: ' + error.message);
            }
        }

        // =================================================================
        // Chapter Writer Functions
        // =================================================================

        let writtenChapters = {};
        let chapterBlueprint = null;

        async function updateChapterWriter() {
            if (!currentProject || !projectData) return;

            const statusEl = document.getElementById('chapterWriterStatus');
            const listEl = document.getElementById('chapterList');
            const writeAllBtn = document.getElementById('writeAllChaptersBtn');

            // Check if chapter_blueprint agent has passed
            let blueprintPassed = false;
            chapterBlueprint = null;

            for (const [layerId, layer] of Object.entries(projectData.layers)) {
                if (layer.agents && layer.agents.chapter_blueprint) {
                    const agent = layer.agents.chapter_blueprint;
                    if (agent.status === 'passed' && agent.output) {
                        blueprintPassed = true;
                        chapterBlueprint = agent.output.content;
                        break;
                    }
                }
            }

            if (!blueprintPassed) {
                statusEl.innerHTML = '<span style="color:#f39c12;">Complete Layer 10 (Chapter Blueprint) first</span>';
                listEl.innerHTML = '';
                writeAllBtn.disabled = true;
                return;
            }

            // Get written chapters
            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters`, {credentials: 'include'});
                if (res.ok) {
                    const data = await res.json();
                    writtenChapters = {};
                    data.chapters.forEach(ch => {
                        writtenChapters[ch.number] = ch;
                    });
                }
            } catch (error) {
                console.error('Failed to load chapters:', error);
            }

            // Render chapter list
            const chapters = chapterBlueprint.chapter_outline || [];
            const totalChapters = chapters.length;
            const writtenCount = Object.keys(writtenChapters).length;

            statusEl.innerHTML = `<span style="color:#2ecc71;">${writtenCount} / ${totalChapters} chapters written</span>`;
            writeAllBtn.disabled = false;

            listEl.innerHTML = chapters.map(ch => {
                const isWritten = writtenChapters[ch.number];
                const className = isWritten ? 'chapter-item written' : 'chapter-item';
                const icon = isWritten ? '✓' : '○';
                return `<span class="${className}" onclick="writeChapter(${ch.number})" title="${ch.title}">${icon} Ch ${ch.number}</span>`;
            }).join('');
        }

        async function writeChapter(chapterNumber) {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const chapterItem = document.querySelector(`.chapter-item[onclick="writeChapter(${chapterNumber})"]`);
            if (chapterItem) {
                chapterItem.classList.add('writing');
                chapterItem.classList.remove('written');
            }

            document.getElementById('chapterWriteProgress').textContent = `Writing Chapter ${chapterNumber}...`;

            try {
                const res = await fetch(`/api/projects/${currentProject}/write-chapter/${chapterNumber}`, {
                    method: 'POST',
                    credentials: 'include'
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Failed to write chapter');
                }

                const data = await res.json();

                if (data.success && data.chapter) {
                    writtenChapters[chapterNumber] = data.chapter;

                    // Update UI
                    if (chapterItem) {
                        chapterItem.classList.remove('writing');
                        chapterItem.classList.add('written');
                        chapterItem.innerHTML = `✓ Ch ${chapterNumber}`;
                    }

                    // Show chapter preview
                    document.getElementById('chapterPreview').classList.remove('hidden');
                    document.getElementById('chapterText').textContent =
                        `Chapter ${chapterNumber}: ${data.chapter.title}\n` +
                        `Words: ${data.chapter.word_count}\n\n` +
                        (data.chapter.text || 'No text generated');

                    document.getElementById('chapterWriteProgress').textContent = `Chapter ${chapterNumber} complete!`;
                }

                await updateChapterWriter();
            } catch (error) {
                console.error('Write chapter error:', error);
                alert('Failed to write chapter: ' + error.message);

                if (chapterItem) {
                    chapterItem.classList.remove('writing');
                }
                document.getElementById('chapterWriteProgress').textContent = 'Error writing chapter';
            }
        }

        let isWritingAllChapters = false;
        let chapterWriteRetries = 0;
        const MAX_CHAPTER_RETRIES = 50; // Allow many retries for 20 chapters

        // Auto-write chapters with timeout-aware batch processing and auto-resume
        async function autoWriteAllChapters() {
            if (!currentProject) return;

            // Refresh chapter writer data
            await updateChapterWriter();

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                console.log('No chapter blueprint available yet');
                return;
            }

            const totalChapters = chapterBlueprint.chapter_outline.length;
            console.log(`Starting auto-write for ${totalChapters} chapters...`);
            document.getElementById('progressStatus').textContent = `Writing chapters...`;

            const btn = document.getElementById('runFullPipelineBtn');
            btn.innerHTML = '<span class="running-indicator"></span>Writing Chapters...';

            isWritingAllChapters = true;
            chapterWriteRetries = 0;

            try {
                let shouldContinue = true;
                let consecutiveFailures = 0;

                while (shouldContinue && chapterWriteRetries < MAX_CHAPTER_RETRIES) {
                    chapterWriteRetries++;

                    document.getElementById('progressStatus').textContent =
                        `Writing chapters... (batch ${chapterWriteRetries})`;

                    try {
                        // Call batch endpoint - writes one chapter at a time to stay under timeout
                        // quick_mode: true writes ~500 word preview chapters (faster, works on Vercel)
                        // quick_mode: false writes full ~3000 word chapters (requires longer timeout)
                        const res = await fetch(`/api/projects/${currentProject}/write-chapters-batch`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({
                                timeout_seconds: 55,  // Use most of 60s limit
                                max_chapters: 1,      // One chapter per request
                                quick_mode: true      // Preview mode for Vercel (faster generation)
                            })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            consecutiveFailures = 0; // Reset on success

                            if (data.chapters_written && data.chapters_written.length > 0) {
                                console.log(`Batch ${chapterWriteRetries}: Wrote chapters ${data.chapters_written.join(', ')}`);
                                document.getElementById('chapterWriteProgress').textContent =
                                    `Completed ${data.completed_count} of ${data.total_chapters} chapters`;
                            }

                            if (data.chapters_failed && data.chapters_failed.length > 0) {
                                console.warn('Some chapters failed:', data.chapters_failed);
                            }

                            shouldContinue = data.should_continue;

                            if (!shouldContinue) {
                                console.log('All chapters written!');
                                document.getElementById('progressStatus').textContent = 'Book Complete!';
                                document.getElementById('chapterWriteProgress').textContent =
                                    `All ${data.total_chapters} chapters written!`;
                            }

                            // Update UI after each batch
                            await updateChapterWriter();

                        } else {
                            consecutiveFailures++;
                            console.error(`Batch ${chapterWriteRetries} failed with status ${res.status}`);

                            // If server error, wait and retry
                            if (res.status >= 500 && consecutiveFailures < 5) {
                                const waitTime = Math.min(consecutiveFailures * 2000, 10000);
                                console.log(`Waiting ${waitTime}ms before retry...`);
                                document.getElementById('progressStatus').textContent =
                                    `Server busy, retrying in ${waitTime/1000}s...`;
                                await new Promise(r => setTimeout(r, waitTime));
                            } else if (consecutiveFailures >= 5) {
                                console.error('Too many consecutive failures, stopping');
                                shouldContinue = false;
                            }
                        }

                    } catch (err) {
                        consecutiveFailures++;
                        console.error(`Batch ${chapterWriteRetries} error:`, err);

                        // Network error - wait and retry
                        if (consecutiveFailures < 5) {
                            const waitTime = Math.min(consecutiveFailures * 2000, 10000);
                            console.log(`Network error, waiting ${waitTime}ms before retry...`);
                            document.getElementById('progressStatus').textContent =
                                `Connection issue, retrying in ${waitTime/1000}s...`;
                            await new Promise(r => setTimeout(r, waitTime));
                        } else {
                            console.error('Too many consecutive failures, stopping');
                            shouldContinue = false;
                        }
                    }

                    // Small delay between batches to be nice to the server
                    if (shouldContinue) {
                        await new Promise(r => setTimeout(r, 1000));
                    }
                }

                if (chapterWriteRetries >= MAX_CHAPTER_RETRIES) {
                    console.warn('Reached max retries');
                    document.getElementById('progressStatus').textContent = 'Writing paused - refresh to continue';
                }

                // Final update
                await loadProjectPipeline();

            } catch (error) {
                console.error('Auto-write chapters error:', error);
            } finally {
                isWritingAllChapters = false;
            }
        }

        async function writeAllChapters() {
            if (!currentProject || isWritingAllChapters) return;

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                alert('Chapter blueprint not available');
                return;
            }

            const chapters = chapterBlueprint.chapter_outline;
            const unwritten = chapters.filter(ch => !writtenChapters[ch.number]);

            if (unwritten.length === 0) {
                alert('All chapters have already been written!');
                return;
            }

            if (!confirm(`This will write ${unwritten.length} chapters. This may take several minutes. Continue?`)) {
                return;
            }

            isWritingAllChapters = true;
            const btn = document.getElementById('writeAllChaptersBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Writing...';

            try {
                for (let i = 0; i < unwritten.length; i++) {
                    const ch = unwritten[i];
                    document.getElementById('chapterWriteProgress').textContent =
                        `Writing chapter ${ch.number} (${i + 1}/${unwritten.length})...`;

                    await writeChapter(ch.number);

                    // Small delay between chapters
                    await new Promise(r => setTimeout(r, 1000));
                }

                document.getElementById('chapterWriteProgress').textContent = 'All chapters complete!';
                alert('All chapters have been written!');
            } catch (error) {
                console.error('Write all chapters error:', error);
                alert('Error during chapter writing: ' + error.message);
            } finally {
                isWritingAllChapters = false;
                btn.disabled = false;
                btn.innerHTML = 'Write All Chapters';
            }
        }

        async function viewWrittenChapter(chapterNumber) {
            if (!currentProject) return;

            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters/${chapterNumber}`, {credentials: 'include'});
                if (!res.ok) throw new Error('Chapter not found');

                const chapter = await res.json();

                document.getElementById('chapterPreview').classList.remove('hidden');
                document.getElementById('chapterText').textContent =
                    `Chapter ${chapter.number}: ${chapter.title}\n` +
                    `Words: ${chapter.word_count}\n\n` +
                    (chapter.text || 'No text');
            } catch (error) {
                console.error('View chapter error:', error);
            }
        }

        // =================================================================
        // Theme Development Functions
        // =================================================================

        let themesData = {};

        async function loadThemesView() {
            if (!currentProject) {
                document.getElementById('noThemeProject').classList.remove('hidden');
                document.getElementById('themesView').classList.add('hidden');
                return;
            }

            document.getElementById('noThemeProject').classList.add('hidden');
            document.getElementById('themesView').classList.remove('hidden');

            // Load project data to get themes
            if (!projectData) {
                const res = await fetch(`/api/projects/${currentProject}`, {credentials: 'include'});
                projectData = await res.json();
            }

            document.getElementById('themesProjectTitle').textContent = `Theme Development: ${projectData.title}`;

            // Get themes from project constraints or existing theme data
            const projectThemes = projectData.user_constraints?.themes || [];

            // Load saved theme development data from localStorage
            const savedThemes = loadThemesFromStorage(currentProject);

            // Merge: ensure all project themes exist in savedThemes
            projectThemes.forEach(theme => {
                if (!savedThemes[theme]) {
                    savedThemes[theme] = createEmptyTheme(theme);
                }
            });

            themesData = savedThemes;
            renderThemes();
        }

        function createEmptyTheme(name) {
            return {
                name: name,
                meaning: '',
                universal_truth: '',
                story_manifestation: '',
                character_connections: '',
                key_scenes: '',
                symbols_motifs: '',
                arc: '',
                questions: ''
            };
        }

        function renderThemes() {
            const container = document.getElementById('themesList');

            if (Object.keys(themesData).length === 0) {
                container.innerHTML = '<p style="color:#888;text-align:center;padding:2rem;">No themes defined yet. Add themes above or go back to your project settings.</p>';
                return;
            }

            container.innerHTML = Object.entries(themesData).map(([key, theme]) => `
                <div class="theme-card" id="theme-${key.replace(/\s+/g, '-')}">
                    <div class="theme-header" onclick="toggleTheme('${key}')">
                        <span class="theme-name">${theme.name}</span>
                        <div>
                            <button class="theme-delete" onclick="event.stopPropagation(); deleteTheme('${key}')">Delete</button>
                            <span class="theme-toggle">▼</span>
                        </div>
                    </div>
                    <div class="theme-content">
                        <div class="theme-field">
                            <label>Core Meaning</label>
                            <textarea placeholder="What does this theme mean in the context of your story?"
                                onchange="updateTheme('${key}', 'meaning', this.value)">${theme.meaning || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "Gaslighting represents the erosion of self-trust when those we love manipulate our perception of reality."</div>
                        </div>

                        <div class="theme-field">
                            <label>Universal Truth</label>
                            <textarea placeholder="What universal truth does this theme explore?"
                                onchange="updateTheme('${key}', 'universal_truth', this.value)">${theme.universal_truth || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "Our sense of reality depends on external validation, making us vulnerable to those who control our environment."</div>
                        </div>

                        <div class="theme-field">
                            <label>Story Manifestation</label>
                            <textarea placeholder="How does this theme manifest in your story's events?"
                                onchange="updateTheme('${key}', 'story_manifestation', this.value)">${theme.story_manifestation || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "The protagonist's husband dismisses her concerns as paranoia, her therapist adjusts her medication, neighbors corroborate lies."</div>
                        </div>

                        <div class="theme-field">
                            <label>Character Connections</label>
                            <textarea placeholder="Which characters embody or challenge this theme?"
                                onchange="updateTheme('${key}', 'character_connections', this.value)">${theme.character_connections || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "Mara (victim), David (unwitting enabler), Elise (perpetrator), Dr. Reeves (institutional gaslighting)"</div>
                        </div>

                        <div class="theme-field">
                            <label>Key Scenes</label>
                            <textarea placeholder="List pivotal scenes that explore this theme"
                                onchange="updateTheme('${key}', 'key_scenes', this.value)">${theme.key_scenes || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "Ch 5: David finds her research, calls therapist. Ch 12: Medication increase makes Mara foggy. Ch 18: Planted evidence scene."</div>
                        </div>

                        <div class="theme-field">
                            <label>Symbols & Motifs</label>
                            <textarea placeholder="What symbols or recurring motifs represent this theme?"
                                onchange="updateTheme('${key}', 'symbols_motifs', this.value)">${theme.symbols_motifs || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "Windows (trapped, looking out), mirrors (fractured reflection), medication bottles, locked doors."</div>
                        </div>

                        <div class="theme-field">
                            <label>Thematic Arc</label>
                            <textarea placeholder="How does this theme evolve from beginning to end?"
                                onchange="updateTheme('${key}', 'arc', this.value)">${theme.arc || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "Beginning: Mara doubts herself. Middle: Evidence mounts but so does gaslighting. End: She trusts herself regardless of others' validation."</div>
                        </div>

                        <div class="theme-field">
                            <label>Thematic Questions</label>
                            <textarea placeholder="What questions does this theme ask the reader?"
                                onchange="updateTheme('${key}', 'questions', this.value)">${theme.questions || ''}</textarea>
                            <div class="theme-examples"><strong>Example:</strong> "How do we know what's real? Who has the power to define reality? What happens when help becomes harm?"</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function toggleTheme(key) {
            const card = document.getElementById(`theme-${key.replace(/\s+/g, '-')}`);
            if (card) {
                card.classList.toggle('expanded');
            }
        }

        function updateTheme(key, field, value) {
            if (themesData[key]) {
                themesData[key][field] = value;
                // Auto-save on change
                saveThemesToStorage(currentProject, themesData);
            }
        }

        function addNewTheme() {
            const input = document.getElementById('newThemeName');
            const name = input.value.trim();

            if (!name) {
                alert('Please enter a theme name');
                return;
            }

            if (themesData[name]) {
                alert('This theme already exists');
                return;
            }

            themesData[name] = createEmptyTheme(name);
            saveThemesToStorage(currentProject, themesData);
            renderThemes();

            input.value = '';

            // Auto-expand the new theme
            setTimeout(() => toggleTheme(name), 100);
        }

        function deleteTheme(key) {
            if (!confirm(`Delete theme "${key}"? This cannot be undone.`)) return;

            delete themesData[key];
            saveThemesToStorage(currentProject, themesData);
            renderThemes();
        }

        function saveThemes() {
            saveThemesToStorage(currentProject, themesData);
            document.getElementById('themeSaveStatus').textContent = 'Saved!';
            setTimeout(() => {
                document.getElementById('themeSaveStatus').textContent = '';
            }, 2000);
        }

        function saveThemesToStorage(projectId, themes) {
            try {
                const key = `book_themes_${projectId}`;
                localStorage.setItem(key, JSON.stringify(themes));
            } catch (error) {
                console.error('Failed to save themes:', error);
            }
        }

        function loadThemesFromStorage(projectId) {
            try {
                const key = `book_themes_${projectId}`;
                const saved = localStorage.getItem(key);
                return saved ? JSON.parse(saved) : {};
            } catch (error) {
                console.error('Failed to load themes:', error);
                return {};
            }
        }

        async function generateThemeIdeas() {
            if (!currentProject) return;

            alert('AI theme generation will analyze your project and suggest theme development ideas. This feature requires the pipeline to be run first.');

            // For now, show helpful prompts based on theme names
            const suggestions = Object.keys(themesData).map(theme => {
                return getThemeSuggestions(theme);
            }).join('\n\n');

            if (suggestions) {
                alert('Theme Development Tips:\n\n' + suggestions);
            }
        }

        function getThemeSuggestions(theme) {
            const tips = {
                'gaslighting': 'GASLIGHTING: Show subtle manipulation escalating. Use unreliable memories, changed objects, denied conversations. The reader should sometimes doubt along with the protagonist.',
                'trust': 'TRUST: Explore who deserves trust and why. Show trust broken and rebuilt. Consider institutional trust vs personal trust.',
                'memory': 'MEMORY: Use fragmented recollections, conflicting accounts, recovered memories. Memory as both weapon and shield.',
                'motherhood': 'MOTHERHOOD: Explore protective instincts, sacrifice, inherited trauma, the gap between ideal and reality of mothering.',
                'suburban secrets': 'SUBURBAN SECRETS: Perfect lawns hiding dysfunction. HOA rules as control. Neighbors who see everything but say nothing.',
                'hidden identity': 'HIDDEN IDENTITY: Layers of self - who we show vs who we are. Documents, photos, digital footprints. The work of maintaining a lie.'
            };

            const lowerTheme = theme.toLowerCase();
            for (const [key, tip] of Object.entries(tips)) {
                if (lowerTheme.includes(key) || key.includes(lowerTheme)) {
                    return tip;
                }
            }
            return `${theme.toUpperCase()}: Consider how this theme connects to your protagonist's journey and what universal truth it reveals.`;
        }

        // =================================================================
        // Image Generation Functions
        // =================================================================

        let currentImageKey = null;
        let imageGenAvailable = false;

        async function loadImagesView() {
            if (!currentProject) {
                document.getElementById('noImageProject').classList.remove('hidden');
                document.getElementById('imagesView').classList.add('hidden');
                return;
            }

            document.getElementById('noImageProject').classList.add('hidden');
            document.getElementById('imagesView').classList.remove('hidden');

            // Check image API status
            await checkImageApiStatus();

            // Load project data if needed
            if (!projectData) {
                const res = await fetch(`/api/projects/${currentProject}`, {credentials: 'include'});
                projectData = await res.json();
            }

            // Load visual analysis status
            await loadVisualAnalysis();

            // Populate chapter select
            await populateChapterSelect();

            // Load existing images
            await loadProjectImages();
        }

        async function loadVisualAnalysis() {
            try {
                const res = await fetch(`/api/projects/${currentProject}/visual-analysis`, {credentials: 'include'});
                if (!res.ok) return;

                const data = await res.json();
                const avail = data.pipeline_data_available || {};

                // Update checkboxes
                updateVisualCheck('vd_protagonist', avail.has_protagonist);
                updateVisualCheck('vd_setting', avail.has_setting);
                updateVisualCheck('vd_mood', avail.has_mood);
                updateVisualCheck('vd_themes', data.visual_analysis?.themes?.length > 0);
                updateVisualCheck('vd_symbols', avail.has_symbols);
                updateVisualCheck('vd_hook', avail.has_story_hook);

                // Store for later use
                window.currentVisualAnalysis = data.visual_analysis;
            } catch (error) {
                console.error('Failed to load visual analysis:', error);
            }
        }

        function updateVisualCheck(id, hasData) {
            const el = document.getElementById(id);
            if (el) {
                if (hasData) {
                    el.innerHTML = el.innerHTML.replace('&#x2610;', '&#x2611;');
                    el.style.color = '#2ecc71';
                } else {
                    el.innerHTML = el.innerHTML.replace('&#x2611;', '&#x2610;');
                    el.style.color = '#888';
                }
            }
        }

        function viewFullAnalysis() {
            if (!window.currentVisualAnalysis) {
                alert('No visual analysis data available. Run the pipeline first.');
                return;
            }

            const va = window.currentVisualAnalysis;
            let msg = `VISUAL ANALYSIS FOR "${va.title}"\n`;
            msg += `${'='.repeat(40)}\n\n`;

            msg += `GENRE: ${va.genre}\n`;
            msg += `THEMES: ${(va.themes || []).join(', ') || 'Not defined'}\n\n`;

            if (va.story_hook) {
                msg += `STORY HOOK:\n${va.story_hook}\n\n`;
            }

            if (va.protagonist) {
                msg += `PROTAGONIST:\n`;
                msg += `  Name: ${va.protagonist.name || 'Unknown'}\n`;
                msg += `  Appearance: ${va.protagonist.appearance || 'Not described'}\n`;
                msg += `  Traits: ${(va.protagonist.traits || []).join(', ') || 'Not defined'}\n\n`;
            }

            if (va.setting) {
                msg += `SETTING:\n`;
                msg += `  Location: ${va.setting.location || 'Unknown'}\n`;
                msg += `  Environment: ${va.setting.environment || 'Not described'}\n`;
                msg += `  Atmosphere: ${va.setting.atmosphere || 'Not defined'}\n\n`;
            }

            if (va.mood) {
                msg += `MOOD/TONE: ${va.mood}\n\n`;
            }

            if (va.key_symbols && va.key_symbols.length > 0) {
                msg += `KEY SYMBOLS: ${va.key_symbols.join(', ')}\n\n`;
            }

            msg += `\nThis data is used to create accurate, story-aware image prompts.`;

            alert(msg);
        }

        async function checkImageApiStatus() {
            const dotEl = document.getElementById('imageApiDot');
            const textEl = document.getElementById('imageApiText');

            try {
                const res = await fetch('/api/system/image-status', {credentials: 'include'});
                const data = await res.json();

                if (data.available) {
                    dotEl.style.background = '#2ecc71';
                    textEl.textContent = 'Image generation ready (Google AI)';
                    imageGenAvailable = true;
                } else {
                    dotEl.style.background = '#e74c3c';
                    textEl.innerHTML = `Image generation unavailable: ${data.reason}<br><small>Add GOOGLE_AI_API_KEY to Railway environment variables. Get free key at <a href="https://aistudio.google.com" target="_blank" style="color:#00d4ff;">aistudio.google.com</a></small>`;
                    imageGenAvailable = false;
                }
            } catch (error) {
                dotEl.style.background = '#e74c3c';
                textEl.textContent = 'Error checking image status';
                imageGenAvailable = false;
            }
        }

        async function populateChapterSelect() {
            const select = document.getElementById('chapterSelect');
            select.innerHTML = '<option value="">-- Select a chapter --</option>';

            // Get chapters from blueprint or manuscript
            let chapters = [];

            if (projectData) {
                // Try blueprint first
                for (const layer of Object.values(projectData.layers || {})) {
                    if (layer.agents?.chapter_blueprint?.output?.content?.chapter_outline) {
                        chapters = layer.agents.chapter_blueprint.output.content.chapter_outline;
                        break;
                    }
                }
            }

            // If no blueprint, try manuscript
            if (chapters.length === 0) {
                try {
                    const res = await fetch(`/api/projects/${currentProject}/chapters`, {credentials: 'include'});
                    if (res.ok) {
                        const data = await res.json();
                        chapters = data.chapters || [];
                    }
                } catch (e) {}
            }

            chapters.forEach(ch => {
                const opt = document.createElement('option');
                opt.value = ch.number;
                opt.textContent = `Chapter ${ch.number}: ${ch.title || 'Untitled'}`;
                select.appendChild(opt);
            });
        }

        async function loadProjectImages() {
            try {
                const res = await fetch(`/api/projects/${currentProject}/images`, {credentials: 'include'});
                if (!res.ok) return;

                const data = await res.json();
                renderImagePreviews(data.images || []);
            } catch (error) {
                console.error('Failed to load images:', error);
            }
        }

        function renderImagePreviews(images) {
            const coverPreviews = document.getElementById('coverPreviews');
            const chapterPreviews = document.getElementById('chapterPreviews');

            const covers = images.filter(img => img.type?.startsWith('cover_'));
            const chapters = images.filter(img => img.type === 'chapter_illustration');

            if (covers.length > 0) {
                coverPreviews.innerHTML = covers.map(img => `
                    <div class="image-preview-item" onclick="viewImage('${img.key}')">
                        <div class="image-placeholder" id="preview-${img.key}">Loading...</div>
                        <span class="image-preview-label">${img.key.replace('cover_', '').toUpperCase()}</span>
                    </div>
                `).join('');

                // Load actual images
                covers.forEach(img => loadImagePreview(img.key));
            } else {
                coverPreviews.innerHTML = '<p style="color:#666;font-size:0.85rem;">No covers generated yet</p>';
            }

            if (chapters.length > 0) {
                chapterPreviews.innerHTML = chapters.map(img => `
                    <div class="image-preview-item" onclick="viewImage('${img.key}')">
                        <div class="image-placeholder" id="preview-${img.key}">Loading...</div>
                        <span class="image-preview-label">Ch ${img.chapter_number}</span>
                    </div>
                `).join('');

                // Load actual images
                chapters.forEach(img => loadImagePreview(img.key));
            } else {
                chapterPreviews.innerHTML = '<p style="color:#666;font-size:0.85rem;">No chapter images generated yet</p>';
            }
        }

        async function loadImagePreview(imageKey) {
            try {
                const res = await fetch(`/api/projects/${currentProject}/images/${imageKey}`, {credentials: 'include'});
                if (!res.ok) return;

                const data = await res.json();
                const previewEl = document.getElementById(`preview-${imageKey}`);

                if (previewEl && data.image_base64) {
                    const img = document.createElement('img');
                    img.src = `data:image/${data.format || 'png'};base64,${data.image_base64}`;
                    img.alt = imageKey;
                    previewEl.replaceWith(img);
                }
            } catch (error) {
                console.error(`Failed to load preview for ${imageKey}:`, error);
            }
        }

        async function generateCover(coverType) {
            if (!currentProject || !imageGenAvailable) {
                alert('Image generation not available. Please add GOOGLE_AI_API_KEY to your Railway environment.');
                return;
            }

            const btn = document.getElementById(coverType === 'front' ? 'genFrontBtn' : 'genBackBtn');
            const statusEl = document.getElementById('coverGenStatus');

            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Generating...';
            statusEl.textContent = `Generating ${coverType} cover... This may take 30-60 seconds.`;

            try {
                const style = document.getElementById('coverStyle').value;

                const res = await fetch(`/api/projects/${currentProject}/generate-cover`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify({
                        cover_type: coverType,
                        style: style
                    })
                });

                const data = await res.json();

                if (data.success) {
                    statusEl.textContent = `${coverType.charAt(0).toUpperCase() + coverType.slice(1)} cover generated!`;
                    await loadProjectImages();
                } else {
                    statusEl.textContent = `Error: ${data.error || 'Generation failed'}`;
                }
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                btn.disabled = false;
                btn.textContent = `Generate ${coverType.charAt(0).toUpperCase() + coverType.slice(1)} Cover`;
            }
        }

        async function generateChapterImage() {
            if (!currentProject || !imageGenAvailable) {
                alert('Image generation not available. Please add GOOGLE_AI_API_KEY to your Railway environment.');
                return;
            }

            const chapterNum = document.getElementById('chapterSelect').value;
            if (!chapterNum) {
                alert('Please select a chapter first');
                return;
            }

            const btn = document.getElementById('genChapterBtn');
            const statusEl = document.getElementById('chapterGenStatus');

            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Generating...';
            statusEl.textContent = `Generating illustration for Chapter ${chapterNum}...`;

            try {
                const style = document.getElementById('chapterStyle').value;

                const res = await fetch(`/api/projects/${currentProject}/generate-chapter-image/${chapterNum}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify({
                        chapter_number: parseInt(chapterNum),
                        style: style
                    })
                });

                const data = await res.json();

                if (data.success) {
                    statusEl.textContent = `Chapter ${chapterNum} illustration generated!`;
                    await loadProjectImages();
                } else {
                    statusEl.textContent = `Error: ${data.error || 'Generation failed'}`;
                }
            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate Chapter Illustration';
            }
        }

        async function generateAllChapterImages() {
            if (!currentProject || !imageGenAvailable) {
                alert('Image generation not available.');
                return;
            }

            const select = document.getElementById('chapterSelect');
            const chapters = Array.from(select.options).filter(o => o.value).map(o => o.value);

            if (chapters.length === 0) {
                alert('No chapters available');
                return;
            }

            if (!confirm(`Generate illustrations for ${chapters.length} chapters? This may take several minutes.`)) {
                return;
            }

            const btn = document.getElementById('genAllChaptersBtn');
            const statusEl = document.getElementById('chapterGenStatus');

            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Generating...';

            const style = document.getElementById('chapterStyle').value;

            for (let i = 0; i < chapters.length; i++) {
                const chapterNum = chapters[i];
                statusEl.textContent = `Generating Chapter ${chapterNum} (${i + 1}/${chapters.length})...`;

                try {
                    await fetch(`/api/projects/${currentProject}/generate-chapter-image/${chapterNum}`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        credentials: 'include',
                        body: JSON.stringify({
                            chapter_number: parseInt(chapterNum),
                            style: style
                        })
                    });

                    await loadProjectImages();
                } catch (error) {
                    console.error(`Failed to generate chapter ${chapterNum}:`, error);
                }

                // Small delay between generations
                await new Promise(r => setTimeout(r, 2000));
            }

            btn.disabled = false;
            btn.textContent = 'Generate All';
            statusEl.textContent = 'All chapter illustrations generated!';
        }

        async function viewImage(imageKey) {
            currentImageKey = imageKey;

            try {
                const res = await fetch(`/api/projects/${currentProject}/images/${imageKey}`, {credentials: 'include'});
                if (!res.ok) return;

                const data = await res.json();

                const modalImg = document.getElementById('modalImage');
                modalImg.src = `data:image/${data.format || 'png'};base64,${data.image_base64}`;

                const modalInfo = document.getElementById('modalInfo');
                modalInfo.innerHTML = `
                    <strong>${imageKey}</strong><br>
                    Style: ${data.style || 'N/A'}<br>
                    <small>Prompt: ${(data.prompt || '').substring(0, 200)}...</small>
                `;

                document.getElementById('imageModal').classList.remove('hidden');
            } catch (error) {
                console.error('Failed to load image:', error);
            }
        }

        function closeImageModal() {
            document.getElementById('imageModal').classList.add('hidden');
            currentImageKey = null;
        }

        function downloadCurrentImage() {
            const modalImg = document.getElementById('modalImage');
            const link = document.createElement('a');
            link.href = modalImg.src;
            link.download = `${currentImageKey || 'image'}.png`;
            link.click();
        }

        async function deleteCurrentImage() {
            if (!currentImageKey || !confirm('Delete this image?')) return;

            try {
                const res = await fetch(`/api/projects/${currentProject}/images/${currentImageKey}`, {
                    method: 'DELETE',
                    credentials: 'include'
                });

                if (res.ok) {
                    closeImageModal();
                    await loadProjectImages();
                }
            } catch (error) {
                console.error('Failed to delete image:', error);
            }
        }

        checkAuth();
    </script>
</body>
</html>
