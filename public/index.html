<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Million Dollar Book Machine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            min-height: 100vh;
            color: #e4e4e4;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 1rem; }

        /* Login */
        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .login-card {
            background: rgba(255,255,255,0.05);
            padding: 2rem;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }
        .login-card h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 1rem;
        }
        .header h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.5rem;
        }

        /* Forms */
        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        label { display: block; margin-bottom: 0.25rem; color: #888; font-size: 0.9rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }
        .btn-danger { background: rgba(231,76,60,0.2); color: #e74c3c; }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card h2 { color: #00d4ff; margin-bottom: 1rem; font-size: 1.2rem; }
        .card h3 { color: #888; margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; }

        /* Grid */
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
        @media (max-width: 768px) {
            .grid-2, .grid-3 { grid-template-columns: 1fr; }
        }

        /* Pipeline View */
        .pipeline { display: flex; flex-direction: column; gap: 0.5rem; }
        .layer {
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid #333;
        }
        .layer.available { border-left-color: #00d4ff; }
        .layer.in-progress { border-left-color: #f39c12; }
        .layer.completed { border-left-color: #2ecc71; }
        .layer.locked { opacity: 0.5; }
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .layer-name { font-weight: 600; }
        .layer-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        .agents { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem; }
        .agent {
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.2s;
        }
        .agent:hover { background: rgba(0,212,255,0.2); }
        .agent.passed { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .agent.failed { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .agent.running { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Output Panel */
        .output-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }
        .output-panel pre {
            font-family: monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            color: #00d4ff;
        }

        /* Tabs */
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        .tab {
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
        }
        .tab.active { background: linear-gradient(90deg, #00d4ff, #7b2cbf); }

        /* Hidden */
        .hidden { display: none !important; }

        /* API Status Indicator */
        .api-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .api-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            animation: pulse 2s infinite;
        }
        .api-status.active .api-status-dot {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46,204,113,0.5);
        }
        .api-status.inactive .api-status-dot {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231,76,60,0.5);
            animation: none;
        }
        .api-status.active {
            border-color: rgba(46,204,113,0.3);
            background: rgba(46,204,113,0.1);
        }
        .api-status.inactive {
            border-color: rgba(231,76,60,0.3);
            background: rgba(231,76,60,0.1);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stat { text-align: center; padding: 1rem; }
        .stat-value { font-size: 2rem; font-weight: 700; color: #00d4ff; }
        .stat-label { font-size: 0.8rem; color: #888; }

        /* Progress Bar */
        .progress-container {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .progress-title { font-weight: 600; font-size: 1.1rem; }
        .progress-percent { color: #00d4ff; font-weight: 700; font-size: 1.2rem; }
        .progress-bar {
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        .progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #888;
        }

        /* Run Full Button */
        .btn-full-pipeline {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            color: #fff;
            width: 100%;
            padding: 1rem;
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .btn-full-pipeline:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(46,204,113,0.3); }
        .btn-full-pipeline:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Running State */
        .running-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Save/Load Buttons */
        .btn-save { background: linear-gradient(90deg, #3498db, #2980b9); color: #fff; }
        .btn-load { background: rgba(52,152,219,0.2); color: #3498db; border: 1px solid #3498db; }
        .btn-export { background: linear-gradient(90deg, #9b59b6, #8e44ad); color: #fff; }
        .btn-write { background: linear-gradient(90deg, #e67e22, #d35400); color: #fff; }
        .file-input-hidden { display: none; }
        .save-load-section {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .auto-save-indicator {
            font-size: 0.75rem;
            color: #2ecc71;
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .auto-save-indicator::before {
            content: "●";
            font-size: 0.5rem;
        }

        /* Chapter Writer Section */
        .chapter-writer-section {
            background: rgba(230,126,34,0.1);
            border: 1px solid rgba(230,126,34,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .chapter-writer-section h3 {
            color: #e67e22;
            margin-bottom: 0.75rem;
        }
        .chapter-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .chapter-item {
            padding: 0.5rem 0.75rem;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .chapter-item:hover { background: rgba(230,126,34,0.2); }
        .chapter-item.written { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .chapter-item.writing { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Export Section */
        .export-section {
            background: rgba(155,89,182,0.1);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .export-section h3 {
            color: #9b59b6;
            margin-bottom: 0.75rem;
        }
        .export-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Screen -->
        <div class="login-screen" id="loginScreen">
            <div class="login-card">
                <h1>Million Dollar Book Machine</h1>
                <p style="color:#888;margin-bottom:2rem;">AI-Powered Book Development</p>
                <form id="loginForm">
                    <input type="password" id="password" placeholder="Enter password" required>
                    <button type="submit" class="btn btn-primary" style="width:100%">Sign In</button>
                </form>
                <p id="loginError" class="hidden" style="color:#e74c3c;margin-top:1rem;">Invalid password</p>
            </div>
        </div>

        <!-- Main App -->
        <div id="appContent" class="hidden">
            <div class="header">
                <h1>Million Dollar Book Machine</h1>
                <div style="display:flex;align-items:center;gap:1rem;">
                    <div id="apiStatus" class="api-status">
                        <span class="api-status-dot"></span>
                        <span class="api-status-text">Checking API...</span>
                    </div>
                    <button class="btn btn-danger btn-small" onclick="logout()">Sign Out</button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <div class="tab active" onclick="showTab('projects')">Projects</div>
                <div class="tab" onclick="showTab('newProject')">New Project</div>
                <div class="tab" onclick="showTab('pipeline')">Pipeline</div>
            </div>

            <!-- Projects Tab -->
            <div id="projectsTab">
                <div class="card">
                    <h2>Your Projects</h2>
                    <div id="projectsList"></div>
                    <div class="save-load-section">
                        <button class="btn btn-load btn-small" onclick="document.getElementById('importFile').click()">
                            Import Project
                        </button>
                        <input type="file" id="importFile" class="file-input-hidden" accept=".json" onchange="importProject(event)">
                        <button class="btn btn-secondary btn-small" onclick="restoreFromLocalStorage()">
                            Restore from Browser
                        </button>
                        <span class="auto-save-indicator" id="autoSaveStatus">Auto-save enabled</span>
                    </div>
                </div>
            </div>

            <!-- New Project Tab -->
            <div id="newProjectTab" class="hidden">
                <div class="card">
                    <h2>Create New Book Project</h2>
                    <form id="newProjectForm">
                        <div class="grid-2">
                            <div>
                                <label>Book Title *</label>
                                <input type="text" id="projectTitle" required placeholder="Your book title">
                            </div>
                            <div>
                                <label>Genre *</label>
                                <select id="projectGenre" required>
                                    <option value="">Select genre</option>
                                    <option value="literary_fiction">Literary Fiction</option>
                                    <option value="thriller">Thriller</option>
                                    <option value="mystery">Mystery</option>
                                    <option value="romance">Romance</option>
                                    <option value="sci_fi">Science Fiction</option>
                                    <option value="fantasy">Fantasy</option>
                                    <option value="horror">Horror</option>
                                    <option value="memoir">Memoir</option>
                                    <option value="self_help">Self-Help</option>
                                    <option value="business">Business</option>
                                </select>
                            </div>
                        </div>
                        <label>Book Description / Vision</label>
                        <textarea id="projectDescription" rows="4" placeholder="Describe your book idea..."></textarea>
                        <div class="grid-2">
                            <div>
                                <label>Target Word Count</label>
                                <input type="number" id="projectWordCount" value="80000">
                            </div>
                            <div>
                                <label>Target Audience</label>
                                <input type="text" id="projectAudience" placeholder="e.g., Adults 25-45">
                            </div>
                        </div>
                        <label>Comparable Titles (comma separated)</label>
                        <input type="text" id="projectComps" placeholder="e.g., The Alchemist, Atomic Habits">
                        <label>Themes (comma separated)</label>
                        <input type="text" id="projectThemes" placeholder="e.g., redemption, identity, love">
                        <button type="submit" class="btn btn-primary">Create Project</button>
                    </form>
                </div>
            </div>

            <!-- Pipeline Tab -->
            <div id="pipelineTab" class="hidden">
                <div id="noProjectSelected" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to view its pipeline</p>
                </div>
                <div id="pipelineView" class="hidden">
                    <!-- Progress Bar -->
                    <div class="progress-container">
                        <div class="progress-header">
                            <span class="progress-title" id="progressTitle">Book Development Progress</span>
                            <span class="progress-percent" id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-details">
                            <span id="progressStatus">Ready to start</span>
                            <span id="progressAgents">0 / 0 agents completed</span>
                        </div>
                        <button class="btn btn-full-pipeline" id="runFullPipelineBtn" onclick="runFullPipeline()">
                            Run Full Pipeline (Background)
                        </button>
                        <div id="jobControls" style="margin-top:0.75rem;display:flex;gap:0.5rem;flex-wrap:wrap;">
                            <button class="btn btn-secondary btn-small" id="resumeJobBtn" onclick="resumeLastJob()" disabled>Resume Job</button>
                            <button class="btn btn-danger btn-small" id="cancelJobBtn" onclick="cancelCurrentJob()" disabled>Cancel Job</button>
                        </div>
                        <div class="output-panel" style="margin-top:0.75rem;max-height:220px;">
                            <pre id="jobOutput" style="color:#fff;">No job yet.</pre>
                        </div>
                    </div>

                    <div class="grid-3" style="margin-bottom:1rem;">
                        <div class="card stat">
                            <div class="stat-value" id="statLayers">0</div>
                            <div class="stat-label">Layers</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statAgents">0</div>
                            <div class="stat-label">Agents</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statCompleted">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                    </div>

                    <div class="grid-2">
                        <div class="card">
                            <h2 id="pipelineProjectTitle">Pipeline</h2>
                            <div class="pipeline" id="pipelineLayers"></div>
                            <div style="margin-top:1rem;">
                                <button class="btn btn-primary btn-small" id="runNextBtn" onclick="runNextAgent()">Run Next Agent</button>
                                <button class="btn btn-secondary btn-small" id="runAvailableBtn" onclick="runAllAvailable()">Run All Available</button>
                                <button class="btn btn-save btn-small" onclick="exportProject()">Save Project</button>
                            </div>

                            <!-- Export Section -->
                            <div class="export-section">
                                <h3>Export Documents</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.75rem;">Download your book in different formats</p>
                                <div class="export-buttons">
                                    <button class="btn btn-export btn-small" onclick="exportDocx()">Word Document (.docx)</button>
                                    <button class="btn btn-export btn-small" onclick="exportEpub()">Kindle/EPUB (.epub)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportOutline()">Outline (MD)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportManuscript()">Manuscript (MD)</button>
                                </div>
                                <p id="exportStatus" style="font-size:0.8rem;color:#888;margin-top:0.5rem;"></p>
                            </div>

                            <!-- Chapter Writer Section -->
                            <div class="chapter-writer-section" id="chapterWriterSection">
                                <h3>Chapter Writer</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.5rem;">Write individual chapters after completing Layer 10 (Chapter Blueprint)</p>
                                <div id="chapterWriterStatus"></div>
                                <div class="chapter-list" id="chapterList"></div>
                                <div style="margin-top:0.75rem;">
                                    <button class="btn btn-write btn-small" id="writeAllChaptersBtn" onclick="writeAllChapters()">Write All Chapters</button>
                                    <span id="chapterWriteProgress" style="margin-left:0.5rem;font-size:0.85rem;color:#888;"></span>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <h2>Agent Output</h2>
                            <p id="selectedAgentName" style="color:#888;margin-bottom:0.5rem;">Select an agent to view output</p>
                            <div class="output-panel">
                                <pre id="agentOutput">No output yet</pre>
                            </div>

                            <!-- Chapter Preview -->
                            <div id="chapterPreview" class="hidden" style="margin-top:1rem;">
                                <h3 style="color:#e67e22;margin-bottom:0.5rem;">Chapter Preview</h3>
                                <div class="output-panel" style="max-height:300px;">
                                    <pre id="chapterText" style="white-space:pre-wrap;color:#fff;"></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentProject = null;
        let projectData = null;

        // =================================================================
        // API helpers
        // =================================================================

        async function apiFetch(url, options = {}) {
            const defaults = { credentials: 'include' };
            const merged = { ...defaults, ...options };
            const res = await fetch(url, merged);
            let data;
            try {
                data = await res.json();
            } catch (_) {
                data = { detail: res.statusText || `HTTP ${res.status}` };
            }
            return { ok: res.ok, status: res.status, data };
        }

        function showApiError(msg, { detail, endpoint, status } = {}) {
            const parts = [msg];
            if (status) parts.push(`(HTTP ${status})`);
            if (detail && detail !== msg) parts.push(`— ${detail}`);
            if (endpoint) parts.push(`[${endpoint}]`);
            const full = parts.join(' ');
            console.error('API error:', full);
            const statusEl = document.getElementById('progressStatus');
            if (statusEl) statusEl.textContent = full;
            return full;
        }

        // =================================================================
        // Auto-restore helper for stateless serverless
        // =================================================================

        async function ensureProjectOnServer(projectId) {
            // Check if project exists on server
            const res = await fetch(`/api/projects/${projectId}`, {credentials: 'include'});

            if (res.ok) {
                return true; // Project exists
            }

            if (res.status === 404) {
                // Try to restore from localStorage
                const saved = getLocalStorageProjects();
                const project = saved[projectId];

                if (project) {
                    console.log('Auto-restoring project from localStorage...');
                    try {
                        const importRes = await fetch('/api/projects/import', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            credentials: 'include',
                            body: JSON.stringify(project)
                        });

                        if (importRes.ok) {
                            console.log('Project restored successfully');
                            return true;
                        }
                    } catch (error) {
                        console.error('Failed to restore project:', error);
                    }
                }
            }

            return false;
        }

        // Auth
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const res = await fetch('/api/auth/login', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify({password: document.getElementById('password').value})
            });
            if (res.ok) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            } else {
                document.getElementById('loginError').classList.remove('hidden');
            }
        });

        async function logout() {
            await fetch('/api/auth/logout', {method: 'POST', credentials: 'include'});
            location.reload();
        }

        async function checkAuth() {
            const res = await fetch('/api/auth/check', {credentials: 'include'});
            const data = await res.json();
            if (data.authenticated) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            }
        }

        // API Status Check
        async function checkApiStatus() {
            const statusEl = document.getElementById('apiStatus');
            const dotEl = statusEl.querySelector('.api-status-dot');
            const textEl = statusEl.querySelector('.api-status-text');

            try {
                const res = await fetch('/api/system/llm-status', {credentials: 'include'});
                const data = await res.json();

                if (data.enabled) {
                    statusEl.className = 'api-status active';
                    textEl.textContent = `API Active (${data.model || 'Claude'})`;
                } else {
                    statusEl.className = 'api-status inactive';
                    textEl.textContent = 'API Inactive - Demo Mode';
                    console.warn('API Status:', data.message);
                }
            } catch (error) {
                statusEl.className = 'api-status inactive';
                textEl.textContent = 'API Error';
                console.error('API Status Error:', error);
            }
        }

        // Refresh API status periodically
        setInterval(checkApiStatus, 60000); // Check every minute

        // Tabs
        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="showTab('${tab}')"]`).classList.add('active');
            document.getElementById('projectsTab').classList.add('hidden');
            document.getElementById('newProjectTab').classList.add('hidden');
            document.getElementById('pipelineTab').classList.add('hidden');
            document.getElementById(tab + 'Tab').classList.remove('hidden');
        }

        // Projects
        async function loadProjects() {
            const res = await fetch('/api/projects', {credentials: 'include'});
            const data = await res.json();
            const container = document.getElementById('projectsList');

            if (data.projects.length === 0) {
                container.innerHTML = '<p style="color:#888;">No projects yet. Create your first book!</p>';
            } else {
                container.innerHTML = data.projects.map(p => `
                    <div class="card" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <div>
                            <strong>${p.title}</strong>
                            <span style="color:#888;margin-left:1rem;">${p.status}</span>
                        </div>
                        <button class="btn btn-primary btn-small" onclick="selectProject('${p.project_id}')">Open</button>
                    </div>
                `).join('');
            }
        }

        async function selectProject(projectId) {
            currentProject = projectId;
            await loadProjectPipeline();
            // Auto-attach to latest job (if any) for this project
            await attachToLatestJob();
            showTab('pipeline');
        }

        async function loadProjectPipeline() {
            if (!currentProject) return;

            // Ensure project exists on server (auto-restore if needed)
            const exists = await ensureProjectOnServer(currentProject);
            if (!exists) {
                alert('Project not found. Please create a new project.');
                currentProject = null;
                showTab('projects');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}`, {credentials: 'include'});
            projectData = await res.json();

            document.getElementById('noProjectSelected').classList.add('hidden');
            document.getElementById('pipelineView').classList.remove('hidden');
            document.getElementById('pipelineProjectTitle').textContent = projectData.title;

            // Stats
            const layers = Object.keys(projectData.layers).length;
            let agents = 0, completed = 0;
            Object.values(projectData.layers).forEach(l => {
                Object.values(l.agents).forEach(a => {
                    agents++;
                    if (a.status === 'passed') completed++;
                });
            });
            document.getElementById('statLayers').textContent = layers;
            document.getElementById('statAgents').textContent = agents;
            document.getElementById('statCompleted').textContent = completed;

            // Update progress bar
            const percent = agents > 0 ? Math.round((completed / agents) * 100) : 0;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressAgents').textContent = `${completed} / ${agents} agents completed`;

            // Update progress status
            let status = 'Ready to start';
            if (completed === agents && agents > 0) {
                status = 'Pipeline complete!';
                document.getElementById('runFullPipelineBtn').textContent = 'Pipeline Complete';
                document.getElementById('runFullPipelineBtn').disabled = true;
            } else {
                // Reset button to runnable state (guards against stale state from previous project)
                if (!isRunningPipeline) {
                    document.getElementById('runFullPipelineBtn').textContent = 'Run Full Pipeline (Background)';
                    document.getElementById('runFullPipelineBtn').disabled = false;
                }
                if (completed > 0) {
                    const currentLayer = projectData.current_layer || 0;
                    status = `Layer ${currentLayer} in progress`;
                }
            }
            document.getElementById('progressStatus').textContent = status;

            // Render pipeline
            const container = document.getElementById('pipelineLayers');
            container.innerHTML = '';

            Object.entries(projectData.layers).sort((a,b) => a[0] - b[0]).forEach(([layerId, layer]) => {
                const div = document.createElement('div');
                div.className = `layer ${layer.status}`;
                div.innerHTML = `
                    <div class="layer-header">
                        <span class="layer-name">Layer ${layerId}: ${layer.name}</span>
                        <span class="layer-status">${layer.status}</span>
                    </div>
                    <div class="agents">
                        ${Object.entries(layer.agents).map(([aid, a]) => `
                            <span class="agent ${a.status}" onclick="viewAgent('${aid}')" title="${a.status}">${a.status === 'passed' ? '✓' : a.status === 'failed' ? '✗' : '○'} ${aid}</span>
                        `).join('')}
                    </div>
                `;
                container.appendChild(div);
            });
        }

        async function viewAgent(agentId) {
            if (!currentProject) return;
            document.getElementById('selectedAgentName').textContent = agentId;

            const res = await fetch(`/api/projects/${currentProject}/agent/${agentId}/output`, {credentials: 'include'});
            const data = await res.json();

            if (data.output) {
                document.getElementById('agentOutput').textContent = JSON.stringify(data.output, null, 2);
            } else {
                document.getElementById('agentOutput').textContent = data.message || 'No output yet';
            }
        }

        async function runNextAgent() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            if (data.available_agents.length > 0) {
                const agent = data.available_agents[0];
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
                await loadProjectPipeline();
                viewAgent(agent.id);
            } else {
                alert('No agents available to run');
            }
        }

        async function runAllAvailable() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            // Loop: re-fetch available agents after each batch so newly-unlocked
            // layers are also executed in the same click.
            while (true) {
                const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
                const data = await res.json();
                if (!data.available_agents || data.available_agents.length === 0) break;
                for (const agent of data.available_agents) {
                    await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                        method: 'POST',
                        credentials: 'include'
                    });
                }
            }
            await loadProjectPipeline();
        }

        let isRunningPipeline = false;
        let currentJobId = null;
        let jobPollTimer = null;

        function _setJobButtons({ resumeEnabled = false, cancelEnabled = false } = {}) {
            document.getElementById('resumeJobBtn').disabled = !resumeEnabled;
            document.getElementById('cancelJobBtn').disabled = !cancelEnabled;
        }

        function _saveLastJob(jobId) {
            try {
                if (currentProject) {
                    localStorage.setItem(`md_book_last_job_${currentProject}`, jobId);
                }
            } catch {}
        }

        function _loadLastJob() {
            try {
                if (!currentProject) return null;
                return localStorage.getItem(`md_book_last_job_${currentProject}`);
            } catch {
                return null;
            }
        }

        async function runFullPipeline() {
            if (!currentProject || isRunningPipeline) return;
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            isRunningPipeline = true;
            const btn = document.getElementById('runFullPipelineBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Starting Job...';
            _setJobButtons({ resumeEnabled: false, cancelEnabled: false });

            try {
                const res = await fetch(`/api/projects/${currentProject}/run-job`, {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    credentials: 'include',
                    body: JSON.stringify({ max_iterations: 400 })
                });

                const data = await res.json();
                if (!res.ok) {
                    throw new Error(data.detail || 'Failed to start job');
                }

                currentJobId = data.job_id;
                _saveLastJob(currentJobId);
                document.getElementById('jobOutput').textContent = `Job started: ${currentJobId}\nStatus: ${data.status}`;
                _setJobButtons({ cancelEnabled: true });

                await pollJob(currentJobId);
            } catch (error) {
                console.error('Job start error:', error);
                alert(error.message || 'Failed to start pipeline job');
            } finally {
                isRunningPipeline = false;
                btn.innerHTML = 'Run Full Pipeline (Background)';
                btn.disabled = false;
                await loadProjectPipeline();
            }
        }

        async function pollJob(jobId) {
            if (jobPollTimer) clearInterval(jobPollTimer);

            const tick = async () => {
                try {
                    const res = await fetch(`/api/jobs/${jobId}`, {credentials: 'include'});
                    const job = await res.json();
                    if (!res.ok) {
                        // Job not found usually means the server restarted without a persisted job store,
                        // or the UI is holding an old job id from localStorage.
                        if (res.status === 404) {
                            document.getElementById('jobOutput').textContent =
                                `Job not found on server: ${jobId}\n\n` +
                                `This can happen after a redeploy if jobs aren't persisted.\n` +
                                `Tip: add a Railway volume mounted at /data and set JOB_STORAGE_DIR=/data/jobs.\n\n` +
                                `Click "Run Full Pipeline (Background)" to start a new job.`;
                            currentJobId = null;
                            _setJobButtons({ cancelEnabled: false, resumeEnabled: false });
                            clearInterval(jobPollTimer);
                            jobPollTimer = null;
                            return;
                        }
                        throw new Error(job.detail || 'Failed to fetch job');
                    }

                    const lines = [];
                    lines.push(`Job: ${job.job_id}`);
                    lines.push(`Status: ${job.status}`);
                    if (job.resumed_from_job_id) lines.push(`Resumed from: ${job.resumed_from_job_id}`);
                    if (job.progress) {
                        if (job.progress.last_agent) lines.push(`Last agent: ${job.progress.last_agent}`);
                        if (job.progress.last_gate_message) lines.push(`Gate: ${job.progress.last_gate_message}`);
                        if (job.progress.project_status) lines.push(`Project status: ${job.progress.project_status}`);
                    }
                    if (job.error) lines.push(`Error: ${job.error}`);
                    lines.push('');
                    lines.push('Recent events:');
                    (job.events || []).slice(-12).forEach(ev => {
                        lines.push(`[${ev.ts}] ${ev.kind}: ${ev.message}`);
                    });

                    document.getElementById('jobOutput').textContent = lines.join('\n');

                    const terminal = ['succeeded','failed','cancelled','interrupted'].includes(job.status);
                    if (job.status === 'running' || job.status === 'queued') {
                        _setJobButtons({ cancelEnabled: true, resumeEnabled: false });
                        document.getElementById('progressStatus').textContent = `Background job running (${job.status})...`;
                    } else {
                        _setJobButtons({ cancelEnabled: false, resumeEnabled: terminal && job.status !== 'succeeded' });
                    }

                    // Refresh pipeline view periodically while job runs
                    await loadProjectPipeline();

                    if (terminal) {
                        clearInterval(jobPollTimer);
                        jobPollTimer = null;
                        if (job.status === 'succeeded') {
                            document.getElementById('progressStatus').textContent = 'Pipeline complete! (job succeeded)';
                        } else {
                            document.getElementById('progressStatus').textContent = `Job ended: ${job.status}`;
                        }
                    }
                } catch (e) {
                    console.error('Job poll error:', e);
                }
            };

            await tick();
            jobPollTimer = setInterval(tick, 4000);
        }

        async function cancelCurrentJob() {
            if (!currentJobId) {
                alert('No active job');
                return;
            }
            if (!confirm('Cancel the running job?')) return;
            const res = await fetch(`/api/jobs/${currentJobId}/cancel`, {method:'POST', credentials:'include'});
            const data = await res.json();
            if (!res.ok) {
                alert(data.detail || 'Failed to cancel job');
                return;
            }
            document.getElementById('jobOutput').textContent = 'Cancellation requested.\n' + JSON.stringify(data.job, null, 2);
            _setJobButtons({ cancelEnabled: false, resumeEnabled: true });
        }

        async function resumeLastJob() {
            const last = _loadLastJob();
            if (!last) {
                alert('No previous job found for this project');
                return;
            }
            const res = await fetch(`/api/jobs/${last}/resume`, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                credentials:'include',
                body: JSON.stringify({ max_iterations: 400 })
            });
            const data = await res.json();
            if (!res.ok) {
                alert(data.detail || 'Failed to resume job');
                return;
            }
            currentJobId = data.job_id;
            _saveLastJob(currentJobId);
            document.getElementById('jobOutput').textContent = `Resumed job: ${currentJobId}\nFrom: ${data.resumed_from}`;
            _setJobButtons({ cancelEnabled: true, resumeEnabled: false });
            await pollJob(currentJobId);
        }

        async function attachToLatestJob() {
            if (!currentProject) return;
            try {
                const res = await fetch(`/api/jobs?project_id=${encodeURIComponent(currentProject)}`, {credentials:'include'});
                if (!res.ok) return;
                const data = await res.json();
                const jobs = data.jobs || [];
                if (!Array.isArray(jobs) || jobs.length === 0) {
                    document.getElementById('jobOutput').textContent = 'No job yet.';
                    currentJobId = null;
                    _setJobButtons({ cancelEnabled: false, resumeEnabled: false });
                    return;
                }
                const latest = jobs[0];
                if (latest && latest.job_id) {
                    currentJobId = latest.job_id;
                    _saveLastJob(currentJobId);
                    await pollJob(currentJobId);
                }
            } catch (e) {
                console.error('Failed to attach to latest job:', e);
            }
        }

        // New Project
        document.getElementById('newProjectForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const body = {
                title: document.getElementById('projectTitle').value,
                genre: document.getElementById('projectGenre').value,
                description: document.getElementById('projectDescription').value,
                target_word_count: parseInt(document.getElementById('projectWordCount').value),
                target_audience: document.getElementById('projectAudience').value,
                comparable_titles: document.getElementById('projectComps').value.split(',').map(s => s.trim()).filter(s => s),
                themes: document.getElementById('projectThemes').value.split(',').map(s => s.trim()).filter(s => s)
            };

            const res = await fetch('/api/projects', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify(body)
            });

            if (res.ok) {
                const data = await res.json();
                currentProject = data.project_id;
                document.getElementById('newProjectForm').reset();
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
            }
        });

        // =================================================================
        // Save/Load Functions
        // =================================================================

        const STORAGE_KEY = 'million_dollar_book_projects';

        async function exportProject() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${data.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Also save to localStorage
                saveToLocalStorage(data);
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export project');
            }
        }

        async function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: text
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Import failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" imported successfully!`);
            } catch (error) {
                console.error('Import error:', error);
                alert('Failed to import project: ' + error.message);
            }

            // Reset file input
            event.target.value = '';
        }

        function saveToLocalStorage(projectData) {
            try {
                let saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                saved[projectData.project_id] = {
                    ...projectData,
                    saved_at: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
                updateAutoSaveStatus('Saved');
            } catch (error) {
                console.error('LocalStorage save error:', error);
            }
        }

        function getLocalStorageProjects() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        async function restoreFromLocalStorage() {
            const saved = getLocalStorageProjects();
            const projects = Object.values(saved);

            if (projects.length === 0) {
                alert('No saved projects found in browser storage');
                return;
            }

            // Show list of saved projects
            const choices = projects.map((p, i) =>
                `${i + 1}. ${p.title} (saved: ${new Date(p.saved_at).toLocaleString()})`
            ).join('\n');

            const choice = prompt(`Select a project to restore:\n\n${choices}\n\nEnter number:`);
            if (!choice) return;

            const index = parseInt(choice) - 1;
            if (index < 0 || index >= projects.length) {
                alert('Invalid selection');
                return;
            }

            const project = projects[index];

            try {
                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify(project)
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Restore failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" restored successfully!`);
            } catch (error) {
                console.error('Restore error:', error);
                alert('Failed to restore project: ' + error.message);
            }
        }

        function updateAutoSaveStatus(status) {
            const el = document.getElementById('autoSaveStatus');
            if (el) {
                el.textContent = status;
                setTimeout(() => {
                    el.textContent = 'Auto-save enabled';
                }, 2000);
            }
        }

        // Auto-save after each agent execution
        const originalLoadProjectPipeline = loadProjectPipeline;
        loadProjectPipeline = async function() {
            await originalLoadProjectPipeline();

            // Auto-save to localStorage after loading
            if (currentProject && projectData) {
                try {
                    const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                    if (res.ok) {
                        const data = await res.json();
                        saveToLocalStorage(data);
                    }
                } catch (error) {
                    console.error('Auto-save error:', error);
                }
            }

            // Update chapter writer section
            await updateChapterWriter();
        };

        // =================================================================
        // Export Functions
        // =================================================================

        async function exportOutline() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/outline`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export outline error:', error);
                alert('Failed to export outline. Make sure the pipeline has been run.');
            }
        }

        async function exportManuscript() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/manuscript`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export manuscript error:', error);
                alert('Failed to export manuscript');
            }
        }

        function downloadMarkdown(filename, content) {
            const blob = new Blob([content], {type: 'text/markdown'});
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportDocx() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating Word document...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/docx`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.docx';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'Word document downloaded!';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export DOCX error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export Word document: ' + error.message);
            }
        }

        async function exportEpub() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating EPUB for Kindle...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/epub`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.epub';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'EPUB downloaded! Ready for Kindle.';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export EPUB error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export EPUB: ' + error.message);
            }
        }

        // =================================================================
        // Chapter Writer Functions
        // =================================================================

        let writtenChapters = {};
        let chapterBlueprint = null;

        async function updateChapterWriter() {
            if (!currentProject || !projectData) return;

            const statusEl = document.getElementById('chapterWriterStatus');
            const listEl = document.getElementById('chapterList');
            const writeAllBtn = document.getElementById('writeAllChaptersBtn');

            // Fetch chapter blueprint output from API (project status doesn't include outputs)
            let blueprintPassed = false;
            chapterBlueprint = null;
            try {
                const res = await fetch(`/api/projects/${currentProject}/agent/chapter_blueprint/output`, {credentials:'include'});
                if (res.ok) {
                    const data = await res.json();
                    if (data.output && data.gate_passed) {
                        blueprintPassed = true;
                        chapterBlueprint = data.output;
                    }
                }
            } catch (e) {
                console.error('Failed to fetch chapter blueprint output:', e);
            }

            if (!blueprintPassed) {
                statusEl.innerHTML = '<span style="color:#f39c12;">Complete Layer 10 (Chapter Blueprint) first</span>';
                listEl.innerHTML = '';
                writeAllBtn.disabled = true;
                return;
            }

            // Get written chapters
            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters`, {credentials: 'include'});
                if (res.ok) {
                    const data = await res.json();
                    writtenChapters = {};
                    data.chapters.forEach(ch => {
                        writtenChapters[ch.number] = ch;
                    });
                }
            } catch (error) {
                console.error('Failed to load chapters:', error);
            }

            // Render chapter list
            const chapters = chapterBlueprint.chapter_outline || [];
            const totalChapters = chapters.length;
            const writtenCount = Object.keys(writtenChapters).length;

            statusEl.innerHTML = `<span style="color:#2ecc71;">${writtenCount} / ${totalChapters} chapters written</span>`;
            writeAllBtn.disabled = false;

            listEl.innerHTML = chapters.map(ch => {
                const isWritten = writtenChapters[ch.number];
                const className = isWritten ? 'chapter-item written' : 'chapter-item';
                const icon = isWritten ? '✓' : '○';
                return `<span class="${className}" onclick="writeChapter(${ch.number})" title="${ch.title}">${icon} Ch ${ch.number}</span>`;
            }).join('');
        }

        async function writeChapter(chapterNumber) {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const chapterItem = document.querySelector(`.chapter-item[onclick="writeChapter(${chapterNumber})"]`);
            if (chapterItem) {
                chapterItem.classList.add('writing');
                chapterItem.classList.remove('written');
            }

            const MAX_RETRIES = 3;
            let lastError = null;

            for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                document.getElementById('chapterWriteProgress').textContent =
                    `Writing Chapter ${chapterNumber}...` + (attempt > 1 ? ` (retry ${attempt}/${MAX_RETRIES})` : '');

                try {
                    const res = await fetch(`/api/projects/${currentProject}/write-chapter/${chapterNumber}`, {
                        method: 'POST',
                        credentials: 'include'
                    });

                    if (!res.ok) {
                        let errMsg = 'Failed to write chapter';
                        try { const err = await res.json(); errMsg = err.detail || errMsg; } catch (_) {}
                        throw new Error(errMsg);
                    }

                    const data = await res.json();

                    if (data.success && data.chapter && data.chapter.text) {
                        writtenChapters[chapterNumber] = data.chapter;

                        // Update UI
                        if (chapterItem) {
                            chapterItem.classList.remove('writing');
                            chapterItem.classList.add('written');
                            chapterItem.innerHTML = `✓ Ch ${chapterNumber}`;
                        }

                        // Show chapter preview
                        document.getElementById('chapterPreview').classList.remove('hidden');
                        document.getElementById('chapterText').textContent =
                            `Chapter ${chapterNumber}: ${data.chapter.title}\n` +
                            `Words: ${data.chapter.word_count}\n\n` +
                            (data.chapter.text || 'No text generated');

                        document.getElementById('chapterWriteProgress').textContent = `Chapter ${chapterNumber} complete!`;
                        await updateChapterWriter();
                        return; // success — exit retry loop
                    } else {
                        // Server returned an error result (chapter has no text)
                        lastError = (data.chapter && data.chapter.error) || data.error || 'No text generated';
                        throw new Error(lastError);
                    }

                } catch (error) {
                    lastError = error.message || 'Unknown error';
                    console.warn(`Write chapter ${chapterNumber} attempt ${attempt} failed:`, lastError);

                    if (attempt < MAX_RETRIES) {
                        const backoff = Math.pow(2, attempt) * 1000;
                        document.getElementById('chapterWriteProgress').textContent =
                            `Chapter ${chapterNumber} failed, retrying in ${backoff/1000}s...`;
                        await new Promise(r => setTimeout(r, backoff));
                    }
                }
            }

            // All retries exhausted
            console.error(`Write chapter ${chapterNumber} failed after ${MAX_RETRIES} attempts:`, lastError);
            alert(`Failed to write chapter ${chapterNumber} after ${MAX_RETRIES} attempts: ${lastError}`);

            if (chapterItem) {
                chapterItem.classList.remove('writing');
            }
            document.getElementById('chapterWriteProgress').textContent = `Chapter ${chapterNumber} failed`;
        }

        let isWritingAllChapters = false;

        // Auto-write chapters using background job (polls for completion)
        async function autoWriteAllChapters() {
            if (!currentProject || isWritingAllChapters) return;

            // Refresh chapter writer data
            await updateChapterWriter();

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                console.log('No chapter blueprint available yet');
                return;
            }

            const totalChapters = chapterBlueprint.chapter_outline.length;
            console.log(`Starting background chapter-writing job for ${totalChapters} chapters...`);
            document.getElementById('progressStatus').textContent = `Starting chapter writing job...`;

            const btn = document.getElementById('runFullPipelineBtn');
            btn.innerHTML = '<span class="running-indicator"></span>Writing Chapters...';

            isWritingAllChapters = true;

            const endpoint = `/api/projects/${currentProject}/write-chapters-job`;
            try {
                const { ok, status, data } = await apiFetch(endpoint, { method: 'POST' });

                if (!ok) {
                    if (status === 422) {
                        console.log('Chapter writing skipped:', data.detail);
                        return;
                    }
                    showApiError('Failed to start chapter writing job', {
                        detail: data.detail, endpoint, status
                    });
                    return;
                }

                if (data.job_id === null) {
                    document.getElementById('progressStatus').textContent = 'All chapters already written!';
                    document.getElementById('chapterWriteProgress').textContent =
                        `All ${totalChapters} chapters written!`;
                    await updateChapterWriter();
                    return;
                }

                const jobId = data.job_id;
                currentJobId = jobId;
                _saveLastJob(jobId);
                document.getElementById('jobOutput').textContent =
                    `Chapter writing job started: ${jobId}\nChapters to write: ${data.chapters_to_write}/${data.total_chapters}`;
                _setJobButtons({ cancelEnabled: true, resumeEnabled: false });

                // Poll job status until completion
                await new Promise((resolve) => {
                    const timer = setInterval(async () => {
                        try {
                            const { ok: jok, status: jstatus, data: job } = await apiFetch(`/api/jobs/${jobId}`);
                            if (!jok) {
                                if (jstatus === 404) { clearInterval(timer); resolve(); return; }
                                return;
                            }
                            const prog = job.progress || {};
                            const written = (prog.written || []).length;
                            const total = prog.total || totalChapters;
                            document.getElementById('chapterWriteProgress').textContent =
                                `Written ${written} of ${total} chapters`;
                            document.getElementById('progressStatus').textContent =
                                `Chapter writing job: ${job.status}`;
                            document.getElementById('jobOutput').textContent = [
                                `Job: ${job.job_id}`,
                                `Status: ${job.status}`,
                                `Written: ${written}/${total}`,
                                job.error ? `Error: ${job.error}` : '',
                                '',
                                'Recent events:',
                                ...(job.events || []).slice(-8).map(ev => `[${ev.ts}] ${ev.kind}: ${ev.message}`),
                            ].filter(Boolean).join('\n');

                            const terminal = ['succeeded','failed','cancelled','interrupted','blocked'].includes(job.status);
                            if (terminal) {
                                clearInterval(timer);
                                if (job.status === 'succeeded') {
                                    document.getElementById('progressStatus').textContent = 'All chapters written!';
                                    document.getElementById('chapterWriteProgress').textContent =
                                        `All ${total} chapters written!`;
                                } else {
                                    const failed = (prog.failed || []);
                                    showApiError(`Chapter writing job ended: ${job.status}`, {
                                        detail: job.error || (failed.length ? `${failed.length} chapter(s) failed` : undefined)
                                    });
                                }
                                await updateChapterWriter();
                                await loadProjectPipeline();
                                resolve();
                            }
                        } catch (e) {
                            console.error('Chapter job poll error:', e);
                        }
                    }, 4000);
                });

            } catch (error) {
                showApiError('Auto-write chapters failed (network error)', { detail: error.message, endpoint });
            } finally {
                isWritingAllChapters = false;
            }
        }

        async function writeAllChapters() {
            // Delegate to the background job approach which handles retries,
            // persistence, and doesn't suffer from HTTP connection timeouts.
            await autoWriteAllChapters();
        }

        async function viewWrittenChapter(chapterNumber) {
            if (!currentProject) return;

            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters/${chapterNumber}`, {credentials: 'include'});
                if (!res.ok) throw new Error('Chapter not found');

                const chapter = await res.json();

                document.getElementById('chapterPreview').classList.remove('hidden');
                document.getElementById('chapterText').textContent =
                    `Chapter ${chapter.number}: ${chapter.title}\n` +
                    `Words: ${chapter.word_count}\n\n` +
                    (chapter.text || 'No text');
            } catch (error) {
                console.error('View chapter error:', error);
            }
        }

        checkAuth();
    </script>
</body>
</html>
