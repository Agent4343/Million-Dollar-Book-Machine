<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Million Dollar Book Machine</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            min-height: 100vh;
            color: #e4e4e4;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 1rem; }

        /* Login */
        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        .login-card {
            background: rgba(255,255,255,0.05);
            padding: 2rem;
            border-radius: 16px;
            width: 100%;
            max-width: 400px;
            text-align: center;
        }
        .login-card h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 1rem;
        }
        .header h1 {
            background: linear-gradient(90deg, #00d4ff, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 1.5rem;
        }

        /* Forms */
        input, select, textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        label { display: block; margin-bottom: 0.25rem; color: #888; font-size: 0.9rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: #fff;
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-small { padding: 0.5rem 1rem; font-size: 0.85rem; }
        .btn-danger { background: rgba(231,76,60,0.2); color: #e74c3c; }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card h2 { color: #00d4ff; margin-bottom: 1rem; font-size: 1.2rem; }
        .card h3 { color: #888; margin-bottom: 0.5rem; font-size: 0.9rem; text-transform: uppercase; }

        /* Grid */
        .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
        @media (max-width: 768px) {
            .grid-2, .grid-3 { grid-template-columns: 1fr; }
        }

        /* Pipeline View */
        .pipeline { display: flex; flex-direction: column; gap: 0.5rem; }
        .layer {
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid #333;
        }
        .layer.available { border-left-color: #00d4ff; }
        .layer.in-progress { border-left-color: #f39c12; }
        .layer.completed { border-left-color: #2ecc71; }
        .layer.locked { opacity: 0.5; }
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .layer-name { font-weight: 600; }
        .layer-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }
        .agents { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem; }
        .agent {
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.2s;
        }
        .agent:hover { background: rgba(0,212,255,0.2); }
        .agent.passed { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .agent.failed { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .agent.running { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Output Panel */
        .output-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
        }
        .output-panel pre {
            font-family: monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            color: #00d4ff;
        }

        /* Tabs */
        .tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; }
        .tab {
            padding: 0.5rem 1rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            cursor: pointer;
        }
        .tab.active { background: linear-gradient(90deg, #00d4ff, #7b2cbf); }

        /* Hidden */
        .hidden { display: none !important; }

        /* API Status Indicator */
        .api-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .api-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            animation: pulse 2s infinite;
        }
        .api-status.active .api-status-dot {
            background: #2ecc71;
            box-shadow: 0 0 10px rgba(46,204,113,0.5);
        }
        .api-status.inactive .api-status-dot {
            background: #e74c3c;
            box-shadow: 0 0 10px rgba(231,76,60,0.5);
            animation: none;
        }
        .api-status.active {
            border-color: rgba(46,204,113,0.3);
            background: rgba(46,204,113,0.1);
        }
        .api-status.inactive {
            border-color: rgba(231,76,60,0.3);
            background: rgba(231,76,60,0.1);
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Stats */
        .stat { text-align: center; padding: 1rem; }
        .stat-value { font-size: 2rem; font-weight: 700; color: #00d4ff; }
        .stat-label { font-size: 0.8rem; color: #888; }

        /* Progress Bar */
        .progress-container {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .progress-title { font-weight: 600; font-size: 1.1rem; }
        .progress-percent { color: #00d4ff; font-weight: 700; font-size: 1.2rem; }
        .progress-bar {
            height: 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        .progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #888;
        }

        /* Run Full Button */
        .btn-full-pipeline {
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            color: #fff;
            width: 100%;
            padding: 1rem;
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .btn-full-pipeline:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(46,204,113,0.3); }
        .btn-full-pipeline:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Running State */
        .running-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Save/Load Buttons */
        .btn-save { background: linear-gradient(90deg, #3498db, #2980b9); color: #fff; }
        .btn-load { background: rgba(52,152,219,0.2); color: #3498db; border: 1px solid #3498db; }
        .btn-export { background: linear-gradient(90deg, #9b59b6, #8e44ad); color: #fff; }
        .btn-write { background: linear-gradient(90deg, #e67e22, #d35400); color: #fff; }
        .file-input-hidden { display: none; }
        .save-load-section {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .auto-save-indicator {
            font-size: 0.75rem;
            color: #2ecc71;
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .auto-save-indicator::before {
            content: "●";
            font-size: 0.5rem;
        }

        /* Chapter Writer Section */
        .chapter-writer-section {
            background: rgba(230,126,34,0.1);
            border: 1px solid rgba(230,126,34,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .chapter-writer-section h3 {
            color: #e67e22;
            margin-bottom: 0.75rem;
        }
        .chapter-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .chapter-item {
            padding: 0.5rem 0.75rem;
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .chapter-item:hover { background: rgba(230,126,34,0.2); }
        .chapter-item.written { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .chapter-item.writing { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Export Section */
        .export-section {
            background: rgba(155,89,182,0.1);
            border: 1px solid rgba(155,89,182,0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }
        .export-section h3 {
            color: #9b59b6;
            margin-bottom: 0.75rem;
        }
        .export-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            background: #1a1a3e;
            border-radius: 16px;
            padding: 2rem;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .modal h2 {
            color: #00d4ff;
            margin-bottom: 1rem;
        }
        .modal-actions {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            justify-content: flex-end;
        }
        .chapter-item.has-regen {
            border: 1px solid #f39c12;
        }
        .btn-regen {
            background: linear-gradient(90deg, #f39c12, #e67e22);
            color: #fff;
        }
        .chapter-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Screen -->
        <div class="login-screen" id="loginScreen">
            <div class="login-card">
                <h1>Million Dollar Book Machine</h1>
                <p style="color:#888;margin-bottom:2rem;">AI-Powered Book Development</p>
                <form id="loginForm">
                    <input type="password" id="password" placeholder="Enter password" required>
                    <button type="submit" class="btn btn-primary" style="width:100%">Sign In</button>
                </form>
                <p id="loginError" class="hidden" style="color:#e74c3c;margin-top:1rem;">Invalid password</p>
            </div>
        </div>

        <!-- Main App -->
        <div id="appContent" class="hidden">
            <div class="header">
                <h1>Million Dollar Book Machine</h1>
                <div style="display:flex;align-items:center;gap:1rem;">
                    <div id="apiStatus" class="api-status">
                        <span class="api-status-dot"></span>
                        <span class="api-status-text">Checking API...</span>
                    </div>
                    <button class="btn btn-danger btn-small" onclick="logout()">Sign Out</button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <div class="tab active" onclick="showTab('projects')">Projects</div>
                <div class="tab" onclick="showTab('newProject')">New Project</div>
                <div class="tab" onclick="showTab('pipeline')">Pipeline</div>
            </div>

            <!-- Projects Tab -->
            <div id="projectsTab">
                <div class="card">
                    <h2>Your Projects</h2>
                    <div id="projectsList"></div>
                    <div class="save-load-section">
                        <button class="btn btn-load btn-small" onclick="document.getElementById('importFile').click()">
                            Import Project
                        </button>
                        <input type="file" id="importFile" class="file-input-hidden" accept=".json" onchange="importProject(event)">
                        <button class="btn btn-secondary btn-small" onclick="restoreFromLocalStorage()">
                            Restore from Browser
                        </button>
                        <span class="auto-save-indicator" id="autoSaveStatus">Auto-save enabled</span>
                    </div>
                </div>
            </div>

            <!-- New Project Tab -->
            <div id="newProjectTab" class="hidden">
                <div class="card">
                    <h2>Create New Book Project</h2>
                    <form id="newProjectForm">
                        <div class="grid-2">
                            <div>
                                <label>Book Title *</label>
                                <input type="text" id="projectTitle" required placeholder="Your book title">
                            </div>
                            <div>
                                <label>Genre *</label>
                                <select id="projectGenre" required>
                                    <option value="">Select genre</option>
                                    <option value="literary_fiction">Literary Fiction</option>
                                    <option value="thriller">Thriller</option>
                                    <option value="mystery">Mystery</option>
                                    <option value="romance">Romance</option>
                                    <option value="sci_fi">Science Fiction</option>
                                    <option value="fantasy">Fantasy</option>
                                    <option value="horror">Horror</option>
                                    <option value="memoir">Memoir</option>
                                    <option value="self_help">Self-Help</option>
                                    <option value="business">Business</option>
                                </select>
                            </div>
                        </div>
                        <label>Book Description / Vision</label>
                        <textarea id="projectDescription" rows="4" placeholder="Describe your book idea..."></textarea>
                        <div class="grid-2">
                            <div>
                                <label>Target Word Count</label>
                                <input type="number" id="projectWordCount" value="80000">
                            </div>
                            <div>
                                <label>Target Audience</label>
                                <input type="text" id="projectAudience" placeholder="e.g., Adults 25-45">
                            </div>
                        </div>
                        <label>Comparable Titles (comma separated)</label>
                        <input type="text" id="projectComps" placeholder="e.g., The Alchemist, Atomic Habits">
                        <label>Themes (comma separated)</label>
                        <input type="text" id="projectThemes" placeholder="e.g., redemption, identity, love">
                        <div style="margin-top: 1rem; border-top: 1px solid #333; padding-top: 1rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem;">
                                Story Bible (Optional - for chapter consistency)
                                <span style="font-size: 0.75rem; color: #888; font-weight: normal;">
                                    Paste your character bible, plot timeline, and locked facts here
                                </span>
                            </label>
                            <textarea id="projectStoryBible" rows="8" placeholder="Paste your Story Bible here... This will be injected into every chapter generation to ensure consistency.

Example content:
- Character details (names, traits, backstory)
- Plot timeline and key events
- World rules and settings
- Voice/style guidelines
- Facts that must never change"></textarea>
                        </div>
                        <button type="submit" class="btn btn-primary">Create Project</button>
                    </form>
                </div>
            </div>

            <!-- Pipeline Tab -->
            <div id="pipelineTab" class="hidden">
                <div id="noProjectSelected" class="card">
                    <p style="text-align:center;color:#888;">Select a project from the Projects tab to view its pipeline</p>
                </div>
                <div id="pipelineView" class="hidden">
                    <!-- Progress Bar -->
                    <div class="progress-container">
                        <div class="progress-header">
                            <span class="progress-title" id="progressTitle">Book Development Progress</span>
                            <span class="progress-percent" id="progressPercent">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                        </div>
                        <div class="progress-details">
                            <span id="progressStatus">Ready to start</span>
                            <span id="progressAgents">0 / 0 agents completed</span>
                        </div>
                        <button class="btn btn-full-pipeline" id="runFullPipelineBtn" onclick="runFullPipeline()">
                            Run Full Pipeline
                        </button>
                    </div>

                    <div class="grid-3" style="margin-bottom:1rem;">
                        <div class="card stat">
                            <div class="stat-value" id="statLayers">0</div>
                            <div class="stat-label">Layers</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statAgents">0</div>
                            <div class="stat-label">Agents</div>
                        </div>
                        <div class="card stat">
                            <div class="stat-value" id="statCompleted">0</div>
                            <div class="stat-label">Completed</div>
                        </div>
                    </div>

                    <div class="grid-2">
                        <div class="card">
                            <h2 id="pipelineProjectTitle">Pipeline</h2>
                            <div class="pipeline" id="pipelineLayers"></div>
                            <div style="margin-top:1rem;">
                                <button class="btn btn-primary btn-small" id="runNextBtn" onclick="runNextAgent()">Run Next Agent</button>
                                <button class="btn btn-secondary btn-small" id="runAvailableBtn" onclick="runAllAvailable()">Run All Available</button>
                                <button class="btn btn-save btn-small" onclick="exportProject()">Save Project</button>
                            </div>

                            <!-- Export Section -->
                            <div class="export-section">
                                <h3>Export Documents</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.75rem;">Download your book in different formats</p>
                                <div class="export-buttons">
                                    <button class="btn btn-export btn-small" onclick="exportDocx()">Word Document (.docx)</button>
                                    <button class="btn btn-export btn-small" onclick="exportEpub()">Kindle/EPUB (.epub)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportOutline()">Outline (MD)</button>
                                    <button class="btn btn-secondary btn-small" onclick="exportManuscript()">Manuscript (MD)</button>
                                </div>
                                <p id="exportStatus" style="font-size:0.8rem;color:#888;margin-top:0.5rem;"></p>
                            </div>

                            <!-- Story Bible Section -->
                            <div class="story-bible-section" style="border:1px solid #333;border-radius:8px;padding:0.75rem;margin-bottom:1rem;background:#1a1a1a;">
                                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                                    <h3 style="margin:0;font-size:1rem;">Story Bible</h3>
                                    <button class="btn btn-small" onclick="toggleStoryBible()" id="toggleStoryBibleBtn" style="font-size:0.75rem;">Show/Edit</button>
                                </div>
                                <p id="storyBibleStatus" style="font-size:0.8rem;color:#888;margin:0;">Canonical reference for chapter consistency</p>
                                <div id="storyBibleEditor" class="hidden" style="margin-top:0.5rem;">
                                    <textarea id="storyBibleText" rows="12" style="width:100%;font-size:0.85rem;background:#0d0d0d;color:#fff;border:1px solid #444;border-radius:4px;padding:0.5rem;" placeholder="Paste your Story Bible here...

This document will be injected into EVERY chapter generation to ensure consistency.

Include:
- Character details (names, traits, relationships)
- Plot timeline and key events
- World rules and settings
- Voice/style guidelines
- Locked facts that must never change"></textarea>
                                    <div style="margin-top:0.5rem;display:flex;gap:0.5rem;">
                                        <button class="btn btn-primary btn-small" onclick="saveStoryBible()">Save Story Bible</button>
                                        <span id="storyBibleSaveStatus" style="font-size:0.8rem;color:#888;"></span>
                                    </div>
                                </div>
                            </div>

                            <!-- Chapter Writer Section -->
                            <div class="chapter-writer-section" id="chapterWriterSection">
                                <h3>Chapter Writer</h3>
                                <p style="font-size:0.85rem;color:#888;margin-bottom:0.5rem;">Write individual chapters after completing Layer 10 (Chapter Blueprint)</p>
                                <div id="chapterWriterStatus"></div>
                                <div class="chapter-list" id="chapterList"></div>
                                <div style="margin-top:0.75rem;">
                                    <button class="btn btn-write btn-small" id="writeAllChaptersBtn" onclick="writeAllChapters()">Write All Chapters</button>
                                    <span id="chapterWriteProgress" style="margin-left:0.5rem;font-size:0.85rem;color:#888;"></span>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <h2>Agent Output</h2>
                            <p id="selectedAgentName" style="color:#888;margin-bottom:0.5rem;">Select an agent to view output</p>
                            <div class="output-panel">
                                <pre id="agentOutput">No output yet</pre>
                            </div>

                            <!-- Chapter Preview -->
                            <div id="chapterPreview" class="hidden" style="margin-top:1rem;">
                                <h3 style="color:#e67e22;margin-bottom:0.5rem;">Chapter Preview</h3>
                                <div class="output-panel" style="max-height:300px;">
                                    <pre id="chapterText" style="white-space:pre-wrap;color:#fff;"></pre>
                                </div>
                                <div class="chapter-actions" id="chapterActions">
                                    <button class="btn btn-regen btn-small" onclick="showRegenerateModal()">Regenerate with Feedback</button>
                                    <button class="btn btn-secondary btn-small" onclick="showEditModal()">Edit Manually</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Regenerate Chapter Modal -->
    <div id="regenerateModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Regenerate Chapter <span id="regenChapterNum"></span></h2>
            <p style="color:#888;margin-bottom:1rem;">Provide feedback to improve the chapter. The AI will use your notes and the previous draft to create a better version.</p>

            <label>Feedback / Improvement Notes</label>
            <textarea id="regenFeedback" rows="4" placeholder="Example: Make the dialogue more natural. Add more sensory details. The pacing feels too slow in the middle..."></textarea>

            <label>Specific Issues to Fix (one per line)</label>
            <textarea id="regenErrors" rows="3" placeholder="Example:
Character name inconsistency in paragraph 3
Missing transition between scenes
Dialogue doesn't match character voice"></textarea>

            <div style="margin-top:1rem;">
                <label style="display:flex;align-items:center;gap:0.5rem;">
                    <input type="checkbox" id="regenQuickMode">
                    Quick mode (shorter ~500 word version)
                </label>
            </div>

            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeRegenerateModal()">Cancel</button>
                <button class="btn btn-regen" onclick="regenerateChapter()">Regenerate Chapter</button>
            </div>
        </div>
    </div>

    <!-- Edit Chapter Modal -->
    <div id="editModal" class="modal-overlay hidden">
        <div class="modal">
            <h2>Edit Chapter <span id="editChapterNum"></span></h2>
            <p style="color:#888;margin-bottom:1rem;">Directly edit the chapter text. Your changes will be saved immediately.</p>

            <label>Chapter Title</label>
            <input type="text" id="editChapterTitle" placeholder="Chapter title">

            <label>Chapter Text</label>
            <textarea id="editChapterText" rows="15" style="font-family:monospace;font-size:0.9rem;"></textarea>

            <p style="font-size:0.85rem;color:#888;margin-top:0.5rem;">
                Word count: <span id="editWordCount">0</span>
            </p>

            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeEditModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveChapterEdit()">Save Changes</button>
            </div>
        </div>
    </div>

    <script>
        let currentProject = null;
        let projectData = null;

        // =================================================================
        // Auto-restore helper for stateless serverless
        // =================================================================

        async function ensureProjectOnServer(projectId) {
            // Check if project exists on server
            const res = await fetch(`/api/projects/${projectId}`, {credentials: 'include'});

            if (res.ok) {
                return true; // Project exists
            }

            if (res.status === 404) {
                // Try to restore from localStorage
                const saved = getLocalStorageProjects();
                const project = saved[projectId];

                console.log('Project not on server, checking localStorage...');
                console.log('Available projects in localStorage:', Object.keys(saved));

                if (project) {
                    console.log('Found project in localStorage, restoring...');
                    try {
                        const importRes = await fetch('/api/projects/import', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            credentials: 'include',
                            body: JSON.stringify(project)
                        });

                        if (importRes.ok) {
                            console.log('Project restored successfully');
                            return true;
                        } else {
                            const errData = await importRes.json().catch(() => ({}));
                            console.error('Import failed:', importRes.status, errData);
                        }
                    } catch (error) {
                        console.error('Failed to restore project:', error);
                    }
                } else {
                    console.log('Project NOT found in localStorage');
                }
            }

            return false;
        }

        // Auth
        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const res = await fetch('/api/auth/login', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify({password: document.getElementById('password').value})
            });
            if (res.ok) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            } else {
                document.getElementById('loginError').classList.remove('hidden');
            }
        });

        async function logout() {
            await fetch('/api/auth/logout', {method: 'POST', credentials: 'include'});
            location.reload();
        }

        async function checkAuth() {
            const res = await fetch('/api/auth/check', {credentials: 'include'});
            const data = await res.json();
            if (data.authenticated) {
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('appContent').classList.remove('hidden');
                loadProjects();
                checkApiStatus(); // Check API status after login
            }
        }

        // API Status Check
        async function checkApiStatus() {
            const statusEl = document.getElementById('apiStatus');
            const dotEl = statusEl.querySelector('.api-status-dot');
            const textEl = statusEl.querySelector('.api-status-text');

            try {
                const res = await fetch('/api/system/llm-status', {credentials: 'include'});
                const data = await res.json();

                if (data.enabled) {
                    statusEl.className = 'api-status active';
                    textEl.textContent = `API Active (${data.model || 'Claude'})`;
                } else {
                    statusEl.className = 'api-status inactive';
                    textEl.textContent = 'API Inactive - Demo Mode';
                    console.warn('API Status:', data.message);
                }
            } catch (error) {
                statusEl.className = 'api-status inactive';
                textEl.textContent = 'API Error';
                console.error('API Status Error:', error);
            }
        }

        // Refresh API status periodically
        setInterval(checkApiStatus, 60000); // Check every minute

        // Tabs
        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="showTab('${tab}')"]`).classList.add('active');
            document.getElementById('projectsTab').classList.add('hidden');
            document.getElementById('newProjectTab').classList.add('hidden');
            document.getElementById('pipelineTab').classList.add('hidden');
            document.getElementById(tab + 'Tab').classList.remove('hidden');
        }

        // Projects
        async function loadProjects() {
            const res = await fetch('/api/projects', {credentials: 'include'});
            const data = await res.json();
            const container = document.getElementById('projectsList');

            if (data.projects.length === 0) {
                container.innerHTML = '<p style="color:#888;">No projects yet. Create your first book!</p>';
            } else {
                container.innerHTML = data.projects.map(p => `
                    <div class="card" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <div>
                            <strong>${p.title}</strong>
                            <span style="color:#888;margin-left:1rem;">${p.status}</span>
                        </div>
                        <button class="btn btn-primary btn-small" onclick="selectProject('${p.project_id}')">Open</button>
                    </div>
                `).join('');
            }
        }

        async function selectProject(projectId) {
            currentProject = projectId;
            await loadProjectPipeline();
            showTab('pipeline');
        }

        async function loadProjectPipeline() {
            if (!currentProject) return;

            // Ensure project exists on server (auto-restore if needed)
            const exists = await ensureProjectOnServer(currentProject);
            if (!exists) {
                alert('Project not found. Please create a new project.');
                currentProject = null;
                showTab('projects');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}`, {credentials: 'include'});
            projectData = await res.json();

            document.getElementById('noProjectSelected').classList.add('hidden');
            document.getElementById('pipelineView').classList.remove('hidden');
            document.getElementById('pipelineProjectTitle').textContent = projectData.title;

            // Stats
            const layers = Object.keys(projectData.layers).length;
            let agents = 0, completed = 0;
            Object.values(projectData.layers).forEach(l => {
                Object.values(l.agents).forEach(a => {
                    agents++;
                    if (a.status === 'passed') completed++;
                });
            });
            document.getElementById('statLayers').textContent = layers;
            document.getElementById('statAgents').textContent = agents;
            document.getElementById('statCompleted').textContent = completed;

            // Update progress bar
            const percent = agents > 0 ? Math.round((completed / agents) * 100) : 0;
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressPercent').textContent = percent + '%';
            document.getElementById('progressAgents').textContent = `${completed} / ${agents} agents completed`;

            // Update progress status
            let status = 'Ready to start';
            if (completed === agents && agents > 0) {
                status = 'Pipeline complete!';
                document.getElementById('runFullPipelineBtn').textContent = 'Pipeline Complete';
                document.getElementById('runFullPipelineBtn').disabled = true;
            } else if (completed > 0) {
                const currentLayer = projectData.current_layer || 0;
                status = `Layer ${currentLayer} in progress`;
            }
            document.getElementById('progressStatus').textContent = status;

            // Render pipeline
            const container = document.getElementById('pipelineLayers');
            container.innerHTML = '';

            Object.entries(projectData.layers).sort((a,b) => a[0] - b[0]).forEach(([layerId, layer]) => {
                const div = document.createElement('div');
                div.className = `layer ${layer.status}`;
                div.innerHTML = `
                    <div class="layer-header">
                        <span class="layer-name">Layer ${layerId}: ${layer.name}</span>
                        <span class="layer-status">${layer.status}</span>
                    </div>
                    <div class="agents">
                        ${Object.entries(layer.agents).map(([aid, a]) => `
                            <span class="agent ${a.status}" onclick="viewAgent('${aid}')" title="${a.status}">${a.status === 'passed' ? '✓' : a.status === 'failed' ? '✗' : '○'} ${aid}</span>
                        `).join('')}
                    </div>
                `;
                container.appendChild(div);
            });
        }

        async function viewAgent(agentId) {
            if (!currentProject) return;
            document.getElementById('selectedAgentName').textContent = agentId;

            const res = await fetch(`/api/projects/${currentProject}/agent/${agentId}/output`, {credentials: 'include'});
            const data = await res.json();

            if (data.output) {
                document.getElementById('agentOutput').textContent = JSON.stringify(data.output, null, 2);
            } else {
                document.getElementById('agentOutput').textContent = data.message || 'No output yet';
            }
        }

        async function runNextAgent() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            if (data.available_agents.length > 0) {
                const agent = data.available_agents[0];
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
                await loadProjectPipeline();
                viewAgent(agent.id);
            } else {
                alert('No agents available to run');
            }
        }

        async function runAllAvailable() {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
            const data = await res.json();

            for (const agent of data.available_agents) {
                await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                    method: 'POST',
                    credentials: 'include'
                });
            }
            await loadProjectPipeline();
        }

        let isRunningPipeline = false;

        async function runFullPipeline() {
            if (!currentProject || isRunningPipeline) return;

            // Ensure project exists before starting
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            isRunningPipeline = true;
            const btn = document.getElementById('runFullPipelineBtn');
            const nextBtn = document.getElementById('runNextBtn');
            const availBtn = document.getElementById('runAvailableBtn');

            btn.disabled = true;
            nextBtn.disabled = true;
            availBtn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Running Pipeline...';

            try {
                let hasMore = true;
                let iterations = 0;
                const maxIterations = 100; // Safety limit

                while (hasMore && iterations < maxIterations) {
                    iterations++;

                    // Get available agents (refresh EVERY iteration)
                    const res = await fetch(`/api/projects/${currentProject}/available-agents`, {credentials: 'include'});
                    const data = await res.json();

                    if (data.available_agents.length === 0) {
                        hasMore = false;
                        break;
                    }

                    // Execute only the FIRST available agent, then refresh the list
                    const agent = data.available_agents[0];
                    document.getElementById('progressStatus').textContent = `Running: ${agent.name}`;

                    const execRes = await fetch(`/api/projects/${currentProject}/execute/${agent.id}`, {
                        method: 'POST',
                        credentials: 'include'
                    });

                    if (!execRes.ok) {
                        const errData = await execRes.json().catch(() => ({}));
                        console.error(`Failed to execute ${agent.id}:`, errData.detail || 'Unknown error');
                        // Continue to next iteration - maybe other agents are available
                    }

                    // Update progress after each agent
                    await loadProjectPipeline();
                    viewAgent(agent.id);
                }

                // Final update
                await loadProjectPipeline();

                if (iterations >= maxIterations) {
                    alert('Pipeline stopped: maximum iterations reached. Some agents may have failed.');
                } else {
                    // Pipeline complete - now automatically write all chapters
                    await autoWriteAllChapters();
                }
            } catch (error) {
                console.error('Pipeline error:', error);
                alert('An error occurred during pipeline execution. Check the console for details.');
            } finally {
                isRunningPipeline = false;
                btn.innerHTML = 'Run Full Pipeline';
                btn.disabled = false;
                nextBtn.disabled = false;
                availBtn.disabled = false;
                await loadProjectPipeline();
            }
        }

        // New Project
        document.getElementById('newProjectForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const storyBible = document.getElementById('projectStoryBible').value.trim();

            const body = {
                title: document.getElementById('projectTitle').value,
                genre: document.getElementById('projectGenre').value,
                description: document.getElementById('projectDescription').value,
                target_word_count: parseInt(document.getElementById('projectWordCount').value),
                target_audience: document.getElementById('projectAudience').value,
                comparable_titles: document.getElementById('projectComps').value.split(',').map(s => s.trim()).filter(s => s),
                themes: document.getElementById('projectThemes').value.split(',').map(s => s.trim()).filter(s => s),
                story_bible: storyBible || null  // Include story bible for chapter generation
            };

            const res = await fetch('/api/projects', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                credentials: 'include',
                body: JSON.stringify(body)
            });

            if (res.ok) {
                const data = await res.json();
                currentProject = data.project_id;
                document.getElementById('newProjectForm').reset();
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
            }
        });

        // =================================================================
        // Save/Load Functions
        // =================================================================

        const STORAGE_KEY = 'million_dollar_book_projects';

        async function exportProject() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${data.title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // Also save to localStorage
                saveToLocalStorage(data);
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export project');
            }
        }

        async function importProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const data = JSON.parse(text);

                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: text
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Import failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" imported successfully!`);
            } catch (error) {
                console.error('Import error:', error);
                alert('Failed to import project: ' + error.message);
            }

            // Reset file input
            event.target.value = '';
        }

        function saveToLocalStorage(projectData) {
            try {
                let saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                saved[projectData.project_id] = {
                    ...projectData,
                    saved_at: new Date().toISOString()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
                updateAutoSaveStatus('Saved');
            } catch (error) {
                console.error('LocalStorage save error:', error);
            }
        }

        function getLocalStorageProjects() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
            } catch {
                return {};
            }
        }

        async function restoreFromLocalStorage() {
            const saved = getLocalStorageProjects();
            const projects = Object.values(saved);

            if (projects.length === 0) {
                alert('No saved projects found in browser storage');
                return;
            }

            // Show list of saved projects
            const choices = projects.map((p, i) =>
                `${i + 1}. ${p.title} (saved: ${new Date(p.saved_at).toLocaleString()})`
            ).join('\n');

            const choice = prompt(`Select a project to restore:\n\n${choices}\n\nEnter number:`);
            if (!choice) return;

            const index = parseInt(choice) - 1;
            if (index < 0 || index >= projects.length) {
                alert('Invalid selection');
                return;
            }

            const project = projects[index];

            try {
                const res = await fetch('/api/projects/import', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify(project)
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Restore failed');
                }

                const result = await res.json();
                currentProject = result.project_id;
                await loadProjects();
                await loadProjectPipeline();
                showTab('pipeline');
                alert(`Project "${result.title}" restored successfully!`);
            } catch (error) {
                console.error('Restore error:', error);
                alert('Failed to restore project: ' + error.message);
            }
        }

        function updateAutoSaveStatus(status) {
            const el = document.getElementById('autoSaveStatus');
            if (el) {
                el.textContent = status;
                setTimeout(() => {
                    el.textContent = 'Auto-save enabled';
                }, 2000);
            }
        }

        // Auto-save after each agent execution
        const originalLoadProjectPipeline = loadProjectPipeline;
        loadProjectPipeline = async function() {
            await originalLoadProjectPipeline();

            // Auto-save to localStorage after loading
            if (currentProject && projectData) {
                try {
                    const res = await fetch(`/api/projects/${currentProject}/export`, {credentials: 'include'});
                    if (res.ok) {
                        const data = await res.json();
                        saveToLocalStorage(data);
                    }
                } catch (error) {
                    console.error('Auto-save error:', error);
                }
            }

            // Update chapter writer section
            await updateChapterWriter();
        };

        // =================================================================
        // Export Functions
        // =================================================================

        async function exportOutline() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/outline`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export outline error:', error);
                alert('Failed to export outline. Make sure the pipeline has been run.');
            }
        }

        async function exportManuscript() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            try {
                const res = await fetch(`/api/projects/${currentProject}/export/manuscript`, {credentials: 'include'});
                if (!res.ok) throw new Error('Export failed');

                const data = await res.json();
                downloadMarkdown(data.filename, data.content);
            } catch (error) {
                console.error('Export manuscript error:', error);
                alert('Failed to export manuscript');
            }
        }

        function downloadMarkdown(filename, content) {
            const blob = new Blob([content], {type: 'text/markdown'});
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportDocx() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating Word document...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/docx`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.docx';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'Word document downloaded!';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export DOCX error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export Word document: ' + error.message);
            }
        }

        async function exportEpub() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const statusEl = document.getElementById('exportStatus');
            statusEl.textContent = 'Generating EPUB for Kindle...';

            try {
                // Ensure project exists on server
                if (!await ensureProjectOnServer(currentProject)) {
                    throw new Error('Project not found on server');
                }

                const res = await fetch(`/api/projects/${currentProject}/export/epub`, {credentials: 'include'});
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Export failed');
                }

                const blob = await res.blob();
                const url = URL.createObjectURL(blob);
                const filename = (projectData?.title || 'Book').replace(/[^a-z0-9]/gi, '_') + '.epub';

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                statusEl.textContent = 'EPUB downloaded! Ready for Kindle.';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (error) {
                console.error('Export EPUB error:', error);
                statusEl.textContent = 'Error: ' + error.message;
                alert('Failed to export EPUB: ' + error.message);
            }
        }

        // =================================================================
        // Story Bible Functions
        // =================================================================

        function toggleStoryBible() {
            const editor = document.getElementById('storyBibleEditor');
            editor.classList.toggle('hidden');
            if (!editor.classList.contains('hidden')) {
                loadStoryBible();
            }
        }

        async function loadStoryBible() {
            if (!currentProject) return;

            try {
                const res = await fetch(`/api/projects/${currentProject}/story-bible`, {credentials: 'include'});
                if (res.ok) {
                    const data = await res.json();
                    document.getElementById('storyBibleText').value = data.story_bible || '';
                    document.getElementById('storyBibleStatus').textContent = data.has_story_bible
                        ? `Story bible loaded (${data.story_bible.length} characters)`
                        : 'No story bible set - add one for consistent chapter generation';
                }
            } catch (error) {
                console.error('Failed to load story bible:', error);
            }
        }

        async function saveStoryBible() {
            if (!currentProject) {
                alert('No project selected');
                return;
            }

            const storyBible = document.getElementById('storyBibleText').value;
            const statusEl = document.getElementById('storyBibleSaveStatus');

            statusEl.textContent = 'Saving...';

            try {
                const res = await fetch(`/api/projects/${currentProject}/story-bible`, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    credentials: 'include',
                    body: JSON.stringify({ story_bible: storyBible })
                });

                if (res.ok) {
                    const data = await res.json();
                    statusEl.textContent = `Saved! (${data.story_bible_length} characters)`;
                    statusEl.style.color = '#2ecc71';
                    document.getElementById('storyBibleStatus').textContent = `Story bible saved (${data.story_bible_length} characters)`;
                    setTimeout(() => {
                        statusEl.textContent = '';
                        statusEl.style.color = '#888';
                    }, 3000);
                } else {
                    throw new Error('Failed to save');
                }
            } catch (error) {
                statusEl.textContent = 'Error saving story bible';
                statusEl.style.color = '#e74c3c';
            }
        }

        // =================================================================
        // Chapter Writer Functions
        // =================================================================

        let writtenChapters = {};
        let chapterBlueprint = null;

        async function updateChapterWriter() {
            if (!currentProject || !projectData) return;

            const statusEl = document.getElementById('chapterWriterStatus');
            const listEl = document.getElementById('chapterList');
            const writeAllBtn = document.getElementById('writeAllChaptersBtn');

            // Check if chapter_blueprint agent has passed
            let blueprintPassed = false;
            chapterBlueprint = null;
            let blueprintStatus = 'not found';

            for (const [layerId, layer] of Object.entries(projectData.layers)) {
                if (layer.agents && layer.agents.chapter_blueprint) {
                    const agent = layer.agents.chapter_blueprint;
                    blueprintStatus = agent.status;
                    console.log(`Chapter blueprint found in layer ${layerId}: status=${agent.status}, hasOutput=${!!agent.output}`);
                    if (agent.output) {
                        console.log('Blueprint output keys:', Object.keys(agent.output.content || {}));
                    }
                    if (agent.status === 'passed' && agent.output) {
                        blueprintPassed = true;
                        chapterBlueprint = agent.output.content;
                        break;
                    }
                }
            }

            if (!blueprintPassed) {
                const currentLayer = projectData.current_layer || 0;
                const layersCompleted = Object.entries(projectData.layers)
                    .filter(([id, l]) => l.status === 'completed').length;
                console.log(`Chapter blueprint not ready. Current layer: ${currentLayer}, Completed layers: ${layersCompleted}, Blueprint status: ${blueprintStatus}`);
                statusEl.innerHTML = `<span style="color:#f39c12;">Complete Layer 10 (Chapter Blueprint) first - Currently on layer ${currentLayer} (${layersCompleted} layers completed)</span>`;
                listEl.innerHTML = '';
                writeAllBtn.disabled = true;
                return;
            }

            // Get written chapters
            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters`, {credentials: 'include'});
                if (res.ok) {
                    const data = await res.json();
                    writtenChapters = {};
                    data.chapters.forEach(ch => {
                        writtenChapters[ch.number] = ch;
                    });
                }
            } catch (error) {
                console.error('Failed to load chapters:', error);
            }

            // Render chapter list
            const chapters = chapterBlueprint.chapter_outline || [];
            const totalChapters = chapters.length;
            const writtenCount = Object.keys(writtenChapters).length;

            statusEl.innerHTML = `<span style="color:#2ecc71;">${writtenCount} / ${totalChapters} chapters written</span>`;
            writeAllBtn.disabled = false;

            listEl.innerHTML = chapters.map(ch => {
                const isWritten = writtenChapters[ch.number];
                const className = isWritten ? 'chapter-item written' : 'chapter-item';
                const icon = isWritten ? '✓' : '○';
                return `<span class="${className}" onclick="writeChapter(${ch.number})" title="${ch.title}">${icon} Ch ${ch.number}</span>`;
            }).join('');
        }

        async function writeChapter(chapterNumber) {
            if (!currentProject) return;

            // Ensure project exists
            if (!await ensureProjectOnServer(currentProject)) {
                alert('Project not found on server');
                return;
            }

            const chapterItem = document.querySelector(`.chapter-item[onclick="writeChapter(${chapterNumber})"]`);
            if (chapterItem) {
                chapterItem.classList.add('writing');
                chapterItem.classList.remove('written');
            }

            document.getElementById('chapterWriteProgress').textContent = `Writing Chapter ${chapterNumber}...`;

            try {
                const res = await fetch(`/api/projects/${currentProject}/write-chapter/${chapterNumber}`, {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ quick_mode: false })
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Failed to write chapter');
                }

                const data = await res.json();

                if (data.success && data.chapter) {
                    writtenChapters[chapterNumber] = data.chapter;

                    // Update UI
                    if (chapterItem) {
                        chapterItem.classList.remove('writing');
                        chapterItem.classList.add('written');
                        chapterItem.innerHTML = `✓ Ch ${chapterNumber}`;
                    }

                    // Show chapter preview
                    document.getElementById('chapterPreview').classList.remove('hidden');
                    document.getElementById('chapterText').textContent =
                        `Chapter ${chapterNumber}: ${data.chapter.title}\n` +
                        `Words: ${data.chapter.word_count}\n\n` +
                        (data.chapter.text || 'No text generated');

                    document.getElementById('chapterWriteProgress').textContent = `Chapter ${chapterNumber} complete!`;
                }

                await updateChapterWriter();
            } catch (error) {
                console.error('Write chapter error:', error);
                alert('Failed to write chapter: ' + error.message);

                if (chapterItem) {
                    chapterItem.classList.remove('writing');
                }
                document.getElementById('chapterWriteProgress').textContent = 'Error writing chapter';
            }
        }

        let isWritingAllChapters = false;
        let chapterWriteRetries = 0;
        const MAX_CHAPTER_RETRIES = 50; // Allow many retries for 20 chapters

        // Auto-write chapters with timeout-aware batch processing and auto-resume
        async function autoWriteAllChapters() {
            if (!currentProject) return;

            // Refresh chapter writer data
            await updateChapterWriter();

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                const currentLayer = projectData?.current_layer || 0;
                console.log(`No chapter blueprint available yet - project is on layer ${currentLayer} (need layer 10)`);
                alert(`Chapter blueprint not ready. Run the full pipeline first.\n\nCurrent layer: ${currentLayer}\nRequired: Layer 10 (Chapter Blueprint)`);
                return;
            }

            const totalChapters = chapterBlueprint.chapter_outline.length;
            console.log(`Starting auto-write for ${totalChapters} chapters...`);
            document.getElementById('progressStatus').textContent = `Writing chapters...`;

            const btn = document.getElementById('runFullPipelineBtn');
            btn.innerHTML = '<span class="running-indicator"></span>Writing Chapters...';

            isWritingAllChapters = true;
            chapterWriteRetries = 0;

            try {
                let shouldContinue = true;
                let consecutiveFailures = 0;

                while (shouldContinue && chapterWriteRetries < MAX_CHAPTER_RETRIES) {
                    chapterWriteRetries++;

                    document.getElementById('progressStatus').textContent =
                        `Writing chapters... (batch ${chapterWriteRetries})`;

                    try {
                        // Call batch endpoint - writes one chapter at a time to stay under timeout
                        // quick_mode: true writes ~500 word preview chapters (faster, works on Vercel)
                        // quick_mode: false writes full ~3000 word chapters (requires longer timeout)
                        const res = await fetch(`/api/projects/${currentProject}/write-chapters-batch`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({
                                timeout_seconds: 55,  // Use most of 60s limit
                                max_chapters: 1,      // One chapter per request
                                quick_mode: true      // Preview mode for Vercel (faster generation)
                            })
                        });

                        if (res.ok) {
                            const data = await res.json();
                            consecutiveFailures = 0; // Reset on success

                            if (data.chapters_written && data.chapters_written.length > 0) {
                                console.log(`Batch ${chapterWriteRetries}: Wrote chapters ${data.chapters_written.join(', ')}`);
                                document.getElementById('chapterWriteProgress').textContent =
                                    `Completed ${data.completed_count} of ${data.total_chapters} chapters`;
                            }

                            if (data.chapters_failed && data.chapters_failed.length > 0) {
                                console.warn('Some chapters failed:', data.chapters_failed);
                            }

                            shouldContinue = data.should_continue;

                            if (!shouldContinue) {
                                console.log('All chapters written!');
                                document.getElementById('progressStatus').textContent = 'Book Complete!';
                                document.getElementById('chapterWriteProgress').textContent =
                                    `All ${data.total_chapters} chapters written!`;
                            }

                            // Update UI after each batch
                            await updateChapterWriter();

                        } else {
                            consecutiveFailures++;
                            console.error(`Batch ${chapterWriteRetries} failed with status ${res.status}`);

                            // If server error, wait and retry
                            if (res.status >= 500 && consecutiveFailures < 5) {
                                const waitTime = Math.min(consecutiveFailures * 2000, 10000);
                                console.log(`Waiting ${waitTime}ms before retry...`);
                                document.getElementById('progressStatus').textContent =
                                    `Server busy, retrying in ${waitTime/1000}s...`;
                                await new Promise(r => setTimeout(r, waitTime));
                            } else if (consecutiveFailures >= 5) {
                                console.error('Too many consecutive failures, stopping');
                                shouldContinue = false;
                            }
                        }

                    } catch (err) {
                        consecutiveFailures++;
                        console.error(`Batch ${chapterWriteRetries} error:`, err);

                        // Network error - wait and retry
                        if (consecutiveFailures < 5) {
                            const waitTime = Math.min(consecutiveFailures * 2000, 10000);
                            console.log(`Network error, waiting ${waitTime}ms before retry...`);
                            document.getElementById('progressStatus').textContent =
                                `Connection issue, retrying in ${waitTime/1000}s...`;
                            await new Promise(r => setTimeout(r, waitTime));
                        } else {
                            console.error('Too many consecutive failures, stopping');
                            shouldContinue = false;
                        }
                    }

                    // Small delay between batches to be nice to the server
                    if (shouldContinue) {
                        await new Promise(r => setTimeout(r, 1000));
                    }
                }

                if (chapterWriteRetries >= MAX_CHAPTER_RETRIES) {
                    console.warn('Reached max retries');
                    document.getElementById('progressStatus').textContent = 'Writing paused - refresh to continue';
                }

                // Final update
                await loadProjectPipeline();

            } catch (error) {
                console.error('Auto-write chapters error:', error);
            } finally {
                isWritingAllChapters = false;
            }
        }

        // Background job tracking
        let currentJobId = null;
        let jobPollInterval = null;

        async function writeAllChapters() {
            if (!currentProject || isWritingAllChapters) return;

            if (!chapterBlueprint || !chapterBlueprint.chapter_outline) {
                alert('Chapter blueprint not available');
                return;
            }

            const chapters = chapterBlueprint.chapter_outline;
            const unwritten = chapters.filter(ch => !writtenChapters[ch.number]);

            if (unwritten.length === 0) {
                alert('All chapters have already been written!');
                return;
            }

            // Ask user for mode
            const useBackground = confirm(
                `Write ${unwritten.length} chapters.\n\n` +
                `Click OK for BACKGROUND mode (recommended - handles timeouts)\n` +
                `Click Cancel for SYNC mode (faster but may timeout)`
            );

            if (useBackground) {
                await writeChaptersBackground();
                return;
            }

            isWritingAllChapters = true;
            const btn = document.getElementById('writeAllChaptersBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Writing...';

            try {
                for (let i = 0; i < unwritten.length; i++) {
                    const ch = unwritten[i];
                    document.getElementById('chapterWriteProgress').textContent =
                        `Writing chapter ${ch.number} (${i + 1}/${unwritten.length})...`;

                    await writeChapter(ch.number);

                    // Small delay between chapters
                    await new Promise(r => setTimeout(r, 1000));
                }

                document.getElementById('chapterWriteProgress').textContent = 'All chapters complete!';
                alert('All chapters have been written!');
            } catch (error) {
                console.error('Write all chapters error:', error);
                alert('Error during chapter writing: ' + error.message);
            } finally {
                isWritingAllChapters = false;
                btn.disabled = false;
                btn.innerHTML = 'Write All Chapters';
            }
        }

        async function viewWrittenChapter(chapterNumber) {
            if (!currentProject) return;

            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters/${chapterNumber}`, {credentials: 'include'});
                if (!res.ok) throw new Error('Chapter not found');

                const chapter = await res.json();
                currentViewingChapter = chapterNumber;

                document.getElementById('chapterPreview').classList.remove('hidden');
                document.getElementById('chapterText').textContent =
                    `Chapter ${chapter.number}: ${chapter.title}\n` +
                    `Words: ${chapter.word_count}\n` +
                    (chapter.regeneration_count ? `Regenerations: ${chapter.regeneration_count}\n` : '') +
                    `\n` + (chapter.text || 'No text');
            } catch (error) {
                console.error('View chapter error:', error);
            }
        }

        // =================================================================
        // Chapter Regeneration and Editing
        // =================================================================

        let currentViewingChapter = null;

        function showRegenerateModal() {
            if (!currentViewingChapter) {
                alert('Please select a chapter first');
                return;
            }

            document.getElementById('regenChapterNum').textContent = currentViewingChapter;
            document.getElementById('regenFeedback').value = '';
            document.getElementById('regenErrors').value = '';
            document.getElementById('regenQuickMode').checked = false;
            document.getElementById('regenerateModal').classList.remove('hidden');
        }

        function closeRegenerateModal() {
            document.getElementById('regenerateModal').classList.add('hidden');
        }

        async function regenerateChapter() {
            if (!currentProject || !currentViewingChapter) return;

            const feedback = document.getElementById('regenFeedback').value.trim();
            const errorsText = document.getElementById('regenErrors').value.trim();
            const quickMode = document.getElementById('regenQuickMode').checked;

            const errors = errorsText ? errorsText.split('\n').filter(e => e.trim()) : [];

            if (!feedback && errors.length === 0) {
                if (!confirm('No feedback provided. Regenerate anyway?')) {
                    return;
                }
            }

            closeRegenerateModal();

            // Show progress
            document.getElementById('chapterWriteProgress').textContent = `Regenerating Chapter ${currentViewingChapter}...`;
            document.getElementById('chapterText').textContent = 'Regenerating chapter with your feedback...';

            try {
                const res = await fetch(`/api/projects/${currentProject}/regenerate-chapter/${currentViewingChapter}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        feedback: feedback || null,
                        errors: errors.length > 0 ? errors : null,
                        quick_mode: quickMode
                    })
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Regeneration failed');
                }

                const data = await res.json();

                if (data.success && data.chapter) {
                    document.getElementById('chapterText').textContent =
                        `Chapter ${data.chapter.chapter_number}: ${data.chapter.title}\n` +
                        `Words: ${data.chapter.word_count}\n` +
                        `Regeneration #${data.regeneration_count}\n\n` +
                        (data.chapter.text || 'No text');

                    document.getElementById('chapterWriteProgress').textContent =
                        `Chapter ${currentViewingChapter} regenerated (version ${data.regeneration_count})`;

                    // Update chapter list
                    await updateChapterWriter();
                }
            } catch (error) {
                console.error('Regeneration error:', error);
                alert('Failed to regenerate chapter: ' + error.message);
                document.getElementById('chapterWriteProgress').textContent = 'Regeneration failed';
            }
        }

        function showEditModal() {
            if (!currentViewingChapter || !currentProject) {
                alert('Please select a chapter first');
                return;
            }

            const chapter = writtenChapters[currentViewingChapter];
            if (!chapter) {
                alert('Chapter not found');
                return;
            }

            document.getElementById('editChapterNum').textContent = currentViewingChapter;
            document.getElementById('editChapterTitle').value = chapter.title || `Chapter ${currentViewingChapter}`;
            document.getElementById('editChapterText').value = chapter.text || '';
            updateEditWordCount();
            document.getElementById('editModal').classList.remove('hidden');
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.add('hidden');
        }

        function updateEditWordCount() {
            const text = document.getElementById('editChapterText').value;
            const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
            document.getElementById('editWordCount').textContent = wordCount.toLocaleString();
        }

        // Update word count as user types
        document.getElementById('editChapterText')?.addEventListener('input', updateEditWordCount);

        async function saveChapterEdit() {
            if (!currentProject || !currentViewingChapter) return;

            const text = document.getElementById('editChapterText').value;
            const title = document.getElementById('editChapterTitle').value;

            if (!text.trim()) {
                alert('Chapter text cannot be empty');
                return;
            }

            closeEditModal();

            try {
                const res = await fetch(`/api/projects/${currentProject}/chapters/${currentViewingChapter}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        text: text,
                        title: title || null
                    })
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Save failed');
                }

                const data = await res.json();

                // Update local cache
                if (writtenChapters[currentViewingChapter]) {
                    writtenChapters[currentViewingChapter].text = text;
                    writtenChapters[currentViewingChapter].title = title;
                    writtenChapters[currentViewingChapter].word_count = data.word_count;
                }

                // Update preview
                document.getElementById('chapterText').textContent =
                    `Chapter ${currentViewingChapter}: ${title}\n` +
                    `Words: ${data.word_count}\n` +
                    `(Manually edited)\n\n` + text;

                document.getElementById('chapterWriteProgress').textContent =
                    `Chapter ${currentViewingChapter} saved (${data.word_count} words)`;

                await updateChapterWriter();
            } catch (error) {
                console.error('Save error:', error);
                alert('Failed to save chapter: ' + error.message);
            }
        }

        // =================================================================
        // Background Job Processing
        // =================================================================

        async function writeChaptersBackground() {
            if (!currentProject) return;

            const btn = document.getElementById('writeAllChaptersBtn');
            btn.disabled = true;
            btn.innerHTML = '<span class="running-indicator"></span>Starting job...';
            document.getElementById('chapterWriteProgress').textContent = 'Creating background job...';

            try {
                // Create the background job
                const res = await fetch(`/api/projects/${currentProject}/jobs`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        job_type: 'write_all_chapters',
                        input_data: {
                            quick_mode: true,  // Use quick mode to reduce timeouts
                            start_chapter: 1,
                            end_chapter: chapterBlueprint?.chapter_outline?.length || 20
                        }
                    })
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || 'Failed to create job');
                }

                const data = await res.json();
                currentJobId = data.job_id;

                document.getElementById('chapterWriteProgress').textContent =
                    `Job started! Polling for progress... (Job ID: ${currentJobId.slice(0, 8)}...)`;

                // Start polling for job status
                startJobPolling(currentJobId);

            } catch (error) {
                console.error('Background job error:', error);
                alert('Failed to start background job: ' + error.message);
                btn.disabled = false;
                btn.innerHTML = 'Write All Chapters';
                document.getElementById('chapterWriteProgress').textContent = 'Job creation failed';
            }
        }

        function startJobPolling(jobId) {
            // Clear any existing polling
            if (jobPollInterval) {
                clearInterval(jobPollInterval);
            }

            // Poll every 3 seconds
            jobPollInterval = setInterval(async () => {
                await checkJobStatus(jobId);
            }, 3000);

            // Also check immediately
            checkJobStatus(jobId);
        }

        async function checkJobStatus(jobId) {
            try {
                const res = await fetch(`/api/jobs/${jobId}`, {credentials: 'include'});
                if (!res.ok) {
                    throw new Error('Failed to get job status');
                }

                const job = await res.json();

                // Update UI with progress
                const progressEl = document.getElementById('chapterWriteProgress');
                const btn = document.getElementById('writeAllChaptersBtn');

                if (job.status === 'running') {
                    progressEl.textContent = `${job.progress_message || 'Processing...'} (${job.progress}%)`;
                    btn.innerHTML = `<span class="running-indicator"></span>${job.progress}%`;
                } else if (job.status === 'completed') {
                    // Job completed!
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    currentJobId = null;

                    const result = job.result || {};
                    progressEl.textContent =
                        `Completed! Wrote ${result.chapters_written || 0} chapters ` +
                        `(${(result.total_words || 0).toLocaleString()} words)`;

                    btn.disabled = false;
                    btn.innerHTML = 'Write All Chapters';

                    // Refresh chapter list
                    await updateChapterWriter();

                    if (result.errors && result.errors.length > 0) {
                        alert(`Job completed with ${result.errors.length} error(s). Check the log.`);
                    }
                } else if (job.status === 'failed') {
                    // Job failed
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    currentJobId = null;

                    progressEl.textContent = `Job failed: ${job.error?.slice(0, 100) || 'Unknown error'}`;
                    btn.disabled = false;
                    btn.innerHTML = 'Write All Chapters';

                    alert('Background job failed. Check the progress message for details.');
                } else if (job.status === 'cancelled') {
                    clearInterval(jobPollInterval);
                    jobPollInterval = null;
                    currentJobId = null;

                    progressEl.textContent = 'Job was cancelled';
                    btn.disabled = false;
                    btn.innerHTML = 'Write All Chapters';
                }

            } catch (error) {
                console.error('Job status check error:', error);
                // Don't stop polling on network errors - might be temporary
            }
        }

        function cancelCurrentJob() {
            if (!currentJobId) return;

            if (!confirm('Cancel the current job?')) return;

            fetch(`/api/jobs/${currentJobId}`, {
                method: 'DELETE',
                credentials: 'include'
            }).then(() => {
                document.getElementById('chapterWriteProgress').textContent = 'Job cancellation requested...';
            }).catch(err => {
                console.error('Cancel error:', err);
            });
        }

        // Handle clicking on chapter items to view/select them
        const originalUpdateChapterWriter = updateChapterWriter;
        updateChapterWriter = async function() {
            await originalUpdateChapterWriter();

            // Add click handlers to view chapters
            document.querySelectorAll('.chapter-item.written').forEach(el => {
                el.onclick = function() {
                    const chNum = parseInt(this.textContent.match(/\d+/)?.[0]);
                    if (chNum) {
                        currentViewingChapter = chNum;
                        viewWrittenChapter(chNum);
                    }
                };
            });
        };

        checkAuth();
    </script>
</body>
</html>
